<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LexiEye — Live Pill Counter (robust + fast)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--primary:#007acc;--accent:#d9eaff;--bg:#fdfefe;--glass:rgba(255,255,255,0.2);--border-glass:rgba(255,255,255,0.4);--text:#333}
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.2rem; color:var(--primary); margin:0 0 12px }
    .wrap{ max-width:1000px; margin:auto; border-radius:24px; padding:16px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(20px) }
    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .controls .spacer{ flex:1 }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:16px; padding:10px 14px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .pill{ display:inline-block; padding:4px 10px; border-radius:12px; background:#e8f4ff; border:1px solid #cfe7ff; font-size:1.1rem }
    .err{ color:#b00020; font-size:.95rem; min-height:1.2em }

    .feed{ position:relative; width:100%; max-width:960px; margin-top:10px }
    video{ display:block; width:100%; height:auto; border-radius:18px; border:2px solid var(--primary) }
    #overlay{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; border-radius:18px }
    #count{ font-size:clamp(3rem,12vw,10rem); font-weight:800; line-height:1; font-variant-numeric:tabular-nums; letter-spacing:.02em }
    #fps{ font-size:1rem }

    /* slider */
    .slider-wrap{ display:flex; align-items:center; gap:10px; background:#eef7ff; border:1px solid #cfe7ff; padding:6px 10px; border-radius:14px }
    .slider-wrap label{ font-weight:600; font-size:.95rem }
    input[type=range]{ -webkit-appearance:none; appearance:none; width:180px; height:6px; border-radius:999px; background:#d9eaff; outline:none }
    input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:50%; background:var(--primary); cursor:pointer }
    input[type=range]::-moz-range-thumb{ width:18px; height:18px; border-radius:50%; background:var(--primary); cursor:pointer }
      /* Keep feed size stable during camera restart (iOS Safari) */
    .feed.lock{ height:var(--locked-h, auto); }
    .feed.lock video,
    .feed.lock #overlay{ width:100%; height:100%; object-fit:contain; }
  </style>
</head>
<body>
  <h1>LexiEye</h1>
  <div class="wrap">
    <div class="controls">
      <!-- Keep camera button on the left -->
      <button id="startBtn" class="btn">Enable Camera & Start</button>

      <div class="spacer"></div>

      <!-- On‑device brightness/exposure slider -->
      <div class="slider-wrap">
        <label for="bright">Brightness</label>
        <input id="bright" type="range" min="-60" max="60" step="1" value="0" />
        <span class="pill" id="brightVal">0</span>
      </div>

      <span class="pill"><b id="count">0</b></span>
      <span class="pill" id="fps">0 fps</span>

      <!-- Keep recount on the right -->
      <button id="recountBtn" class="btn">Recount Final</button>
    </div>
    <div class="err" id="err"></div>
    <div class="feed">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
  </div>

<script>
// === LexiEye — robust real‑time pill counter ===
// • Any shape (round/oval/capsule) with dynamic brightness & glare handling
// • Auto polarity (Binary/BinaryInv) for Otsu so dark or light backgrounds work
// • 10s lock per pill, +2s minimum stick so green doesn't drop
// • Final number freezes once stable ≤1 for ~8 frames or after 5s deadline
// • Recount Final restarts camera + pipeline
// • NEW: User brightness slider — tries hardware exposure; otherwise boosts/dims in software.

const startBtn=document.getElementById('startBtn');
const recountBtn=document.getElementById('recountBtn');
const errEl=document.getElementById('err');
const video=document.getElementById('video');
const overlay=document.getElementById('overlay');
const octx=overlay.getContext('2d');
const countEl=document.getElementById('count');
const fpsEl=document.getElementById('fps');
const brightEl=document.getElementById('bright');
const brightVal=document.getElementById('brightVal');

let stream=null, running=false, lastTick=performance.now(), frames=0;
let frameIdx=0;
let startTs=0, frozen=false;
const DEADLINE_MS=5000, STABLE_WIN=8, STABLE_TOL=1; // finalization
const COUNT_FREEZE_MS=10000; // hold final number

// Auto refresh interval: soft detection reset every 20s
const DETECTION_REFRESH_MS=20000;
let autoRefreshTimer=null;

// processing sizes
const PROC_MAX_W=384; let procW=0,procH=0,vidW=0,vidH=0,sX=1,sY=1;

// throttles (bigger = less often)
const PERF={DT_EVERY:2,GRAD_EVERY:2,HOUGH_EVERY:3,CLAHE_EVERY:3};

// locks
const LOCK_MS=10000, MIN_LOCK_MS=2000, DELETE_BASE_MS=6000, LOCK_HALO_SCALE=1.25, LOCK_HALO_PAD=8;

// memory grid (helps re‑confirm dropped pills)
const MEM_CELL=10, MEM_DECAY=0.94, MEM_HIT=1.0, MEM_HIT_NEI=0.5, MEM_SPAWN=3.0;

// edge ring test
const EDGE_RING_MIN_PX=2, EDGE_RING_THICK=0.22, EDGE_MIN_COVER=0.15, EDGE_BIN_BIAS=2;

// User brightness (software fallback). Range [-60..60]
let userBright = 0; // beta offset for convertScaleAbs

// offscreen canvas
const work=document.createElement('canvas'); const wctx=work.getContext('2d');

// cv mats
let src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt,glareMask;
let contours,hierarchy,kSmall,kBig,clahe; let sobelX,sobelY,absX,absY,grad,gradBin;
let thInvert=false;

// caches
const cache={grad:null,gradBin:null,dtMask:null,labMask:null,lcMask:null,glare:null};

// size prior in video pixels
const sizePrior={R:null};

// memory grid
const mem={w:0,h:0,cells:null};

function showErr(m){ errEl.textContent=m||''; console.error(m); }
function odd(n){ return (n%2)?n:n+1; }
function median(a){ const b=[...a].sort((x,y)=>x-y), m=Math.floor(b.length/2); return b.length%2?b[m]:(b[m-1]+b[m])/2; }

async function startCamera(){
  errEl.textContent='';
  const tries=[
    {video:{facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720}}, audio:false},
    {video:{facingMode:{ideal:'environment'}, width:{ideal:960}, height:{ideal:540}}, audio:false},
    {video:true, audio:false}
  ];
  try{ const devs=await navigator.mediaDevices.enumerateDevices(); const back=devs.find(d=>d.kind==='videoinput' && /back|environment/i.test(d.label||'')); if(back) tries.unshift({video:{deviceId:{exact:back.deviceId}, width:{ideal:1280}, height:{ideal:720}}, audio:false}); }catch{}
  for(const c of tries){
    try{
      stream=await navigator.mediaDevices.getUserMedia(c);
      video.srcObject=stream; video.setAttribute('playsinline','true'); await video.play();
      try{ const track=stream.getVideoTracks()[0]; const caps=track.getCapabilities?track.getCapabilities():{}; const adv=[]; if(caps.exposureMode)adv.push({exposureMode:'continuous'}); if(caps.whiteBalanceMode)adv.push({whiteBalanceMode:'continuous'}); if(caps.focusMode)adv.push({focusMode:'continuous'}); if(caps.exposureCompensation)adv.push({exposureCompensation:caps.exposureCompensation.max}); if(caps.torch)adv.push({torch:true}); if(adv.length) track.applyConstraints({advanced:adv}).catch(()=>{});}catch{}
      return true;
    }catch(e){ console.warn('gUM fail',c,e); }
  }
  showErr('Could not start the camera. Use HTTPS or localhost.');
  return false;
}

function syncBuffers(){
  vidW=video.videoWidth||640; vidH=video.videoHeight||480;
  overlay.width=vidW; overlay.height=vidH; overlay.style.width=vidW+'px'; overlay.style.height=vidH+'px'; video.style.width=vidW+'px';
  procW=Math.min(vidW,PROC_MAX_W); procH=Math.round(vidH*(procW/vidW)); work.width=procW; work.height=procH; sX=vidW/procW; sY=vidH/procH;
  [src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt,glareMask,contours,hierarchy,kSmall,kBig,clahe,sobelX,sobelY,absX,absY,grad,gradBin].forEach(m=>{try{m&&m.delete()}catch{}});
  src=new cv.Mat(procH,procW,cv.CV_8UC4); rgb=new cv.Mat(procH,procW,cv.CV_8UC3); hsv=new cv.Mat(procH,procW,cv.CV_8UC3); gray=new cv.Mat(procH,procW,cv.CV_8UC1); blur=new cv.Mat(procH,procW,cv.CV_8UC1); mask=new cv.Mat(procH,procW,cv.CV_8UC1); adaptive=new cv.Mat(procH,procW,cv.CV_8UC1); hsvMask=new cv.Mat(procH,procW,cv.CV_8UC1); fused=new cv.Mat(procH,procW,cv.CV_8UC1); dt=new cv.Mat(procH,procW,cv.CV_32F); glareMask=new cv.Mat(procH,procW,cv.CV_8UC1); contours=new cv.MatVector(); hierarchy=new cv.Mat();
  const ks=odd(Math.max(3,Math.round(Math.min(procW,procH)*0.02))); const kb=odd(Math.max(9,Math.round(Math.min(procW,procH)*0.07)));
  kSmall=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(ks,ks)); kBig=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(kb,kb));
  try{ clahe=cv.createCLAHE(2.0,new cv.Size(8,8)); }catch{}
  initMemory();
}

function initMemory(){ mem.w=Math.max(1,Math.round(procW/MEM_CELL)); mem.h=Math.max(1,Math.round(procH/MEM_CELL)); mem.cells=new Float32Array(mem.w*mem.h); }
function decayMemory(){ if(!mem.cells) return; const a=mem.cells; for(let i=0;i<a.length;i++){ a[i]*=MEM_DECAY; if(a[i]<0.01) a[i]=0; } }
function depositMemory(cx,cy){ if(!mem.cells) return; const cw=procW/mem.w, ch=procH/mem.h; const ix=Math.max(0,Math.min(mem.w-1,Math.floor(cx/cw))); const iy=Math.max(0,Math.min(mem.h-1,Math.floor(cy/ch))); const i=iy*mem.w+ix; mem.cells[i]+=MEM_HIT; for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(!dx&&!dy) continue; const jx=ix+dx, jy=iy+dy; if(jx>=0&&jx<mem.w&&jy>=0&&jy<mem.h){ mem.cells[jy*mem.w+jx]+=MEM_HIT_NEI; } } } }
function spawnFromMemory(){ const out=[]; if(!mem.cells) return out; const cw=procW/mem.w, ch=procH/mem.h; for(let y=0;y<mem.h;y++){ for(let x=0;x<mem.w;x++){ const v=mem.cells[y*mem.w+x]; if(v>=MEM_SPAWN){ const cx=(x+0.5)*cw, cy=(y+0.5)*ch; const r=Math.max(6,(sizePrior.R||12)/Math.sqrt((sX+sY)/2)); if(regionContrastOK(cx,cy,r*0.9) && ringEdgeOK(cx,cy,r*0.9)){ out.push({cx,cy}); } mem.cells[y*mem.w+x]=0; } } } return out; }

function updateFps(){ frames++; const now=performance.now(); if(now-lastTick>=1000){ fpsEl.textContent=`${frames} fps`; frames=0; lastTick=now; } }
function freezeNow(final){ const now=performance.now(); for(const t of tracker.tracks){ t.lockedUntil=now+COUNT_FREEZE_MS; t.okSince=t.okSince||now; t.okHoldUntil=now+COUNT_FREEZE_MS; } countEl.textContent=String(final); frozen=true; running=false; }

// ===== masks & helpers =====
function hsvBrightMask(){ const chs=new cv.MatVector(); cv.split(hsv,chs); const S=chs.get(1), V=chs.get(2); const meanV=cv.mean(V)[0]; const vMin=Math.max(60,Math.round(meanV-6)); const sMax=170; const vMask=new cv.Mat(), sMask=new cv.Mat(); cv.threshold(V,vMask,vMin,255,cv.THRESH_BINARY); cv.threshold(S,sMask,sMax,255,cv.THRESH_BINARY_INV); cv.bitwise_and(vMask,sMask,hsvMask); cv.morphologyEx(hsvMask,hsvMask,cv.MORPH_OPEN,kSmall); vMask.delete(); sMask.delete(); S.delete(); V.delete(); chs.delete(); }
// Try both polarities for Otsu and keep the best
function choosePolarityAndThreshold(){ const tests=[cv.THRESH_BINARY+cv.THRESH_OTSU, cv.THRESH_BINARY_INV+cv.THRESH_OTSU]; let best={score:-1,inv:false,out:null}; for(const t of tests){ const tmp=new cv.Mat(); cv.threshold(blur,tmp,0,255,t); const clean=new cv.Mat(); cv.morphologyEx(tmp,clean,cv.MORPH_OPEN,kSmall); const vec=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(clean,vec,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE); const total=clean.rows*clean.cols; const lo=total*0.0006, hi=total*0.20; let good=0; for(let i=0;i<vec.size();i++){ const a=cv.contourArea(vec.get(i)); if(a>lo&&a<hi) good++; } if(good>best.score){ if(best.out) best.out.delete(); best={score:good,inv:(t&cv.THRESH_BINARY_INV)!==0,out:clean}; } else { clean.delete(); } tmp.delete(); vec.delete(); hier.delete(); } thInvert=best.inv; if(mask) try{mask.delete()}catch{}; mask=best.out; }

function buildGlareMask(){ const chs=new cv.MatVector(); cv.split(hsv,chs); const S=chs.get(1), V=chs.get(2); const hi=new cv.Mat(), lowS=new cv.Mat(); cv.threshold(V,hi,240,255,cv.THRESH_BINARY); cv.threshold(S,lowS,25,255,cv.THRESH_BINARY_INV); cv.bitwise_and(hi,lowS,glareMask); const k=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(5,5)); cv.dilate(glareMask,glareMask,k); k.delete(); hi.delete(); lowS.delete(); S.delete(); V.delete(); chs.delete(); }

function buildLocalContrastMask(){ const med=new cv.Mat(), mean=new cv.Mat(), diff=new cv.Mat(), out=new cv.Mat(); cv.medianBlur(gray,med,7); cv.blur(med,mean,new cv.Size(31,31)); cv.subtract(gray,mean,diff); const abs=new cv.Mat(); cv.convertScaleAbs(diff,abs,2.0,0); cv.threshold(abs,out,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU); cv.morphologyEx(out,out,cv.MORPH_OPEN,kSmall); med.delete(); mean.delete(); diff.delete(); abs.delete(); return out; }

function buildGradients(){ if((frameIdx%PERF.GRAD_EVERY)===0 || !cache.grad){ sobelX=new cv.Mat(); sobelY=new cv.Mat(); absX=new cv.Mat(); absY=new cv.Mat(); grad=new cv.Mat(); gradBin=new cv.Mat(); cv.Sobel(blur,sobelX,cv.CV_16S,1,0,3); cv.Sobel(blur,sobelY,cv.CV_16S,0,1,3); cv.convertScaleAbs(sobelX,absX); cv.convertScaleAbs(sobelY,absY); cv.addWeighted(absX,0.5,absY,0.5,0,grad); const gMean=cv.mean(grad)[0]; cv.threshold(grad,gradBin,Math.max(20,gMean+EDGE_BIN_BIAS),255,cv.THRESH_BINARY); cache.grad&&cache.grad.delete(); cache.gradBin&&cache.gradBin.delete(); cache.grad=grad.clone(); cache.gradBin=gradBin.clone(); } else { grad=cache.grad.clone(); gradBin=cache.gradBin.clone(); } }

function ringEdgeOK(cx,cy,r){ if(glareMask){ const py=Math.max(0,Math.min(procH-1,Math.round(cy))); const px=Math.max(0,Math.min(procW-1,Math.round(cx))); try{ if(glareMask.ucharPtr(py,px)[0]>0) return false; }catch{} }
  const R=Math.max(3,Math.round(r)); const t=Math.max(EDGE_RING_MIN_PX,Math.round(R*EDGE_RING_THICK)); const x0=Math.max(0,Math.round(cx-R-t)); const y0=Math.max(0,Math.round(cy-R-t)); const w=Math.min(procW-x0,2*(R+t)+1); const h=Math.min(procH-y0,2*(R+t)+1); const cxr=Math.round(R+t), cyr=cxr; const ring=cv.Mat.zeros(h,w,cv.CV_8UC1), inner=cv.Mat.zeros(h,w,cv.CV_8UC1); cv.circle(ring,new cv.Point(cxr,cyr),R+t,new cv.Scalar(255,255,255,255),-1); cv.circle(inner,new cv.Point(cxr,cyr),Math.max(1,R-t),new cv.Scalar(255,255,255,255),-1); cv.subtract(ring,inner,ring); const gROI=gradBin.roi(new cv.Rect(x0,y0,w,h)); const inter=new cv.Mat(); cv.bitwise_and(gROI,ring,inter); const c1=cv.countNonZero(inter), c0=cv.countNonZero(ring); ring.delete(); inner.delete(); inter.delete(); gROI.delete(); return (c1/Math.max(1,c0))>EDGE_MIN_COVER; }

function regionContrastOK(cx,cy,r){ const R=Math.max(4,Math.round(r)); const t=Math.max(2,Math.round(R*0.25)); const x0=Math.max(0,Math.round(cx-R-t-2)); const y0=Math.max(0,Math.round(cy-R-t-2)); const w=Math.min(procW-x0,2*(R+t)+5); const h=Math.min(procH-y0,2*(R+t)+5); const cxr=Math.round((cx-x0)), cyr=Math.round((cy-y0)); const inner=cv.Mat.zeros(h,w,cv.CV_8UC1), outer=cv.Mat.zeros(h,w,cv.CV_8UC1); cv.circle(inner,new cv.Point(cxr,cyr),Math.max(2,R-1),new cv.Scalar(255,255,255,255),-1); cv.circle(outer,new cv.Point(cxr,cyr),R+t,new cv.Scalar(255,255,255,255),-1); const ring=new cv.Mat(); cv.subtract(outer,inner,ring); const gROI=gray.roi(new cv.Rect(x0,y0,w,h)); const mIn=new cv.Mat(), sIn=new cv.Mat(); cv.meanStdDev(gROI,mIn,sIn,inner); const mOut=new cv.Mat(), sOut=new cv.Mat(); cv.meanStdDev(gROI,mOut,sOut,ring); const meanIn=mIn.doubleAt(0,0), stdIn=sIn.doubleAt(0,0); const meanOut=mOut.doubleAt(0,0), stdOut=sOut.doubleAt(0,0); inner.delete(); outer.delete(); ring.delete(); gROI.delete(); mIn.delete(); sIn.delete(); mOut.delete(); sOut.delete(); const noise=stdOut; const minGap=Math.max(5,1.6*noise); const maxStdIn=Math.max(50,1.0*noise+24); return (meanIn-meanOut)>=minGap && stdIn<maxStdIn; }

// tracker
const tracker={tracks:[], nextId:1};
function lockedZones(now){ const zones=[]; for(const t of tracker.tracks){ if(t.lockedUntil && now<t.lockedUntil){ const R=Math.max(t.r1||8,t.r2||8)*LOCK_HALO_SCALE+LOCK_HALO_PAD; zones.push({x:t.x,y:t.y,R}); if(t.refreshAt==null) t.refreshAt=(t.firstConfirmedAt||now)+LOCK_MS/2; if(now>=t.refreshAt && (t.matched || (now-t.seen)<200)){ t.lockedUntil=now+LOCK_MS; t.refreshAt=now+LOCK_MS/2; } } if(t.okSince){ t.okHoldUntil=Math.max(t.okHoldUntil||0, now+MIN_LOCK_MS); } if(!t.matched){ t.misses=(t.misses||0)+1; } } return zones; }
function insideAnyZone(x,y,zs){ for(const z of zs){ if(Math.hypot(x-z.x,y-z.y)<=z.R) return true; } return false; }
function assignTracks(dets){ const now=performance.now(); const maxDist=Math.min(vidW,vidH)*0.06; const zones=lockedZones(now); for(const t of tracker.tracks){ t.matched=false; }
  for(const d of dets){ let best=null,bd=1e9; for(const t of tracker.tracks){ const locked=t.lockedUntil && now<t.lockedUntil; if(locked) continue; const dd=Math.hypot(d.x-t.x,d.y-t.y); if(dd<bd && dd<maxDist){ best=t; bd=dd; } } if(best){ best.x=0.7*best.x+0.3*d.x; best.y=0.7*best.y+0.3*d.y; best.r1=0.7*(best.r1||d.r1)+0.3*d.r1; best.r2=0.7*(best.r2||d.r2)+0.3*d.r2; best.a=d.a; best.type=d.type; best.seen=now; best.matched=true; best.age=(best.age||0)+1; best.misses=0; if(d.strong && !best.firstConfirmedAt){ best.firstConfirmedAt=now; best.lockedUntil=now+LOCK_MS; best.refreshAt=now+LOCK_MS/2; } if((best.age||0)>=2 || best.firstConfirmedAt){ if(!best.okSince) best.okSince=now; best.okHoldUntil=Math.max(best.okHoldUntil||0, now+MIN_LOCK_MS); } }
    else if(!insideAnyZone(d.x,d.y,zones)){ const nt={id:tracker.nextId++,x:d.x,y:d.y,r1:d.r1,r2:d.r2,a:d.a,type:d.type||'circle',seen:now,matched:true,age:(d.strong?2:1),firstConfirmedAt:(d.strong?now:null),lockedUntil:(d.strong?now+LOCK_MS:null),refreshAt:(d.strong?now+LOCK_MS/2:null),misses:0,okSince:(d.strong?now:null),okHoldUntil:(d.strong?now+MIN_LOCK_MS:null)}; tracker.tracks.push(nt);} }
  for(const t of tracker.tracks){ if(!t.firstConfirmedAt && (t.age||0)>=2){ t.firstConfirmedAt=now; t.lockedUntil=now+LOCK_MS; t.refreshAt=now+LOCK_MS/2; } }
  tracker.tracks=tracker.tracks.filter(t=>{ if((t.lockedUntil && now<t.lockedUntil) || (t.okHoldUntil && now<t.okHoldUntil)) return true; const life=now-t.seen; const ttl=(t.okSince?DELETE_BASE_MS:1500); return life<ttl; });
}

function process(){ if(!running) return; try{
  if(!video.videoWidth){ requestAnimationFrame(process); return; }
  if(overlay.width!==video.videoWidth || work.width===0){ syncBuffers(); }

  // read frame
  wctx.drawImage(video,0,0,procW,procH); if(src){ try{src.delete();}catch{} } src=cv.imread(work); cv.cvtColor(src,rgb,cv.COLOR_RGBA2RGB); cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV); cv.cvtColor(rgb,gray,cv.COLOR_RGB2GRAY);
  const opened=new cv.Mat(), closed=new cv.Mat(), tophat=new cv.Mat(), blackhat=new cv.Mat(), enh=new cv.Mat();
  cv.morphologyEx(gray,opened,cv.MORPH_OPEN,kBig); cv.morphologyEx(gray,closed,cv.MORPH_CLOSE,kBig);
  cv.subtract(gray,opened,tophat); cv.subtract(closed,gray,blackhat); cv.add(gray,tophat,enh); cv.subtract(enh,blackhat,enh);
  if(clahe && (frameIdx%PERF.CLAHE_EVERY)===0){ try{ clahe.apply(enh,enh);}catch{} }

  // **software brightness tweak**
  if(userBright!==0){ cv.convertScaleAbs(enh, enh, 1.0, userBright); }

  cv.GaussianBlur(enh,blur,new cv.Size(5,5),1.05,1.05);
  opened.delete(); closed.delete(); tophat.delete(); blackhat.delete(); enh.delete();

  buildGradients();

  // === fused mask: (best Otsu ∧ Adaptive) ∨ HSV (when not sprinting)
  choosePolarityAndThreshold();
  const block=odd(Math.max(9,Math.round(Math.min(procW,procH)*0.06)));
  cv.adaptiveThreshold(blur,adaptive,255,cv.ADAPTIVE_THRESH_MEAN_C, thInvert?cv.THRESH_BINARY_INV:cv.THRESH_BINARY, block, 5);
  const both=new cv.Mat(); cv.bitwise_and(mask,adaptive,both);
  if(performance.now()-startTs<3000){ both.copyTo(fused); } else { hsvBrightMask(); cv.bitwise_or(both,hsvMask,fused); }
  both.delete();
  // local-contrast + glare cleanup
  if((frameIdx%3)===0 || !cache.lcMask){ const lc=buildLocalContrastMask(); cache.lcMask&&cache.lcMask.delete(); cache.lcMask=lc.clone(); lc.delete(); }
  cache.lcMask && cv.bitwise_or(fused, cache.lcMask, fused);
  if((frameIdx%3)===0 || !cache.glare){ buildGlareMask(); cache.glare&&cache.glare.delete(); cache.glare=glareMask.clone(); }
  const invGlare=new cv.Mat(); cv.bitwise_not(cache.glare||glareMask, invGlare); cv.bitwise_and(fused, invGlare, fused); invGlare.delete();
  cv.morphologyEx(fused,fused,cv.MORPH_OPEN,kSmall); cv.morphologyEx(fused,fused,cv.MORPH_CLOSE,kSmall);

  // split touching
  let finalMask; if((frameIdx%PERF.DT_EVERY)===0 || !cache.dtMask){ cv.distanceTransform(fused,dt,cv.DIST_L2,3); const dtn=new cv.Mat(); cv.normalize(dt,dtn,0,1,cv.NORM_MINMAX); const kM=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(5,5)); const maxMap=new cv.Mat(); cv.dilate(dtn,maxMap,kM); const localMax=new cv.Mat(); cv.compare(dtn,maxMap,localMax,cv.CMP_EQ); localMax.convertTo(localMax,cv.CV_8U,255); cv.bitwise_and(localMax,fused,localMax); const fg=new cv.Mat(); cv.threshold(dtn,fg,0.20,1,cv.THRESH_BINARY); fg.convertTo(fg,cv.CV_8U,255); cv.bitwise_or(fg,localMax,fg); cv.morphologyEx(fg,fg,cv.MORPH_ERODE,kSmall); finalMask=new cv.Mat(); cv.bitwise_and(fused,fg,finalMask); cache.dtMask&&cache.dtMask.delete(); cache.dtMask=finalMask.clone(); dtn.delete(); fg.delete(); localMax.delete(); maxMap.delete(); }
  else { finalMask=cache.dtMask.clone(); }

  contours.delete(); contours=new cv.MatVector(); hierarchy.delete(); hierarchy=new cv.Mat(); cv.findContours(finalMask,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

  const gMean=cv.mean(gray)[0]; const dets=[]; const eqR=[];
  for(let i=0;i<contours.size();i++){
    const cnt=contours.get(i); const area=cv.contourArea(cnt); if(area<12){ cnt.delete(); continue; }
    const peri=cv.arcLength(cnt,true); const circ=(4*Math.PI*area)/(peri*peri+1e-6); const hull=new cv.Mat(); cv.convexHull(cnt,hull); const solid=area/Math.max(cv.contourArea(hull),1e-6);
    const rect=cv.boundingRect(cnt); const roi=finalMask.roi(rect); const cov=cv.countNonZero(roi)/(rect.width*rect.height); roi.delete();
    const r2=gray.roi(rect); const m=new cv.Mat(); const s=new cv.Mat(); cv.meanStdDev(r2,m,s); const meanG=m.doubleAt(0,0); const stdG=s.doubleAt(0,0); r2.delete(); m.delete(); s.delete();
    let isEllipse=false, ex=0,ey=0,er1=0,er2=0,eang=0; try{ if(cnt.total && cnt.total()>=5){ const rr=cv.fitEllipse(cnt); isEllipse=true; ex=rr.center.x; ey=rr.center.y; er1=rr.size.width/2; er2=rr.size.height/2; eang=rr.angle*Math.PI/180; } }catch{}
    const aspect=isEllipse ? Math.min(er1,er2)/Math.max(er1,er2) : 1;
    const roundOK=(circ>=0.58 && solid>=0.82 && aspect>=0.70);
    const capsuleOK=(solid>=0.86 && aspect>=0.30 && aspect<0.80);
    const brightOK=(meanG > gMean-8 && stdG < 95);
    const coverOK=(cov>0.04);
    let edgeOK=true, contrastOK=false, strong=false;
    if(roundOK){ const M=cv.moments(cnt); const cxp=M.m10/(M.m00||1), cyp=M.m01/(M.m00||1); const rp=Math.max(6,Math.sqrt(area/Math.PI)); edgeOK=ringEdgeOK(cxp,cyp,rp); contrastOK=regionContrastOK(cxp,cyp,rp); }
    else if(capsuleOK && isEllipse){ const rr=Math.max(er1,er2); contrastOK=regionContrastOK(ex,ey,rr); }
    strong=((edgeOK||contrastOK) && brightOK && solid>0.82 && circ>0.60);
    if(coverOK && ((roundOK && (edgeOK||contrastOK) && brightOK) || (capsuleOK && contrastOK && brightOK))){ if(roundOK){ const M=cv.moments(cnt); const cx=M.m10/(M.m00||1), cy=M.m01/(M.m00||1); const r=Math.max(6,Math.sqrt(area/Math.PI)); const Rv=r*Math.sqrt((sX+sY)/2); dets.push({type:'circle',x:cx*sX,y:cy*sY,r1:Rv,r2:Rv,a:0,score:circ*solid,strong}); eqR.push(Rv);} else { const Rv=Math.max(er1*sX,er2*sY); dets.push({type:'ellipse',x:ex*sX,y:ey*sY,r1:er1*sX,r2:er2*sY,a:eang,score:solid,strong:false}); eqR.push(Rv);} }
    hull.delete(); cnt.delete();
  }

  // Hough booster (occasionally)
  if((frameIdx%PERF.HOUGH_EVERY)===0){ const tmp=new cv.Mat(), circles=new cv.Mat(); cv.GaussianBlur(blur,tmp,new cv.Size(3,3),1.0,1.0); try{ cv.HoughCircles(tmp,circles,cv.HOUGH_GRADIENT,1.25,Math.max(6,Math.min(procW,procH)*0.05),180,40,5,Math.round(Math.min(procW,procH)*0.25)); }catch{} for(let i=0;i<circles.cols;i++){ const cx=circles.data32F[i*3], cy=circles.data32F[i*3+1], r=circles.data32F[i*3+2]; if(!isFinite(cx)||!isFinite(cy)||!isFinite(r)) continue; const px=Math.min(procW-1,Math.max(0,Math.round(cx))), py=Math.min(procH-1,Math.max(0,Math.round(cy))); if(fused.ucharPtr(py,px)[0]===0) continue; if(!(ringEdgeOK(cx,cy,r)||regionContrastOK(cx,cy,r))) continue; const Rv=r*Math.sqrt((sX+sY)/2); dets.push({type:'circle',x:cx*sX,y:cy*sY,r1:Rv,r2:Rv,a:0,score:0.95,strong:true}); eqR.push(Rv);} tmp.delete(); circles.delete(); }

  if(eqR.length>=3){ const mid=median(eqR.filter(v=>isFinite(v))); sizePrior.R=sizePrior.R?(0.7*sizePrior.R+0.3*mid):mid; }
  const R=sizePrior.R||median(eqR.length?eqR:[12]); const minR=Math.max(5,R*0.35); const maxR=Math.min(Math.min(vidW,vidH)*0.14,R*3.0);

  // NMS + halo filter
  dets.sort((a,b)=>b.r1-a.r1); const merged=[], used=new Array(dets.length).fill(false); for(let i=0;i<dets.length;i++){ if(used[i]) continue; const a=dets[i]; const big=Math.max(a.r1,a.r2), small=Math.min(a.r1,a.r2); if(big>maxR || small<minR*0.6){ used[i]=true; continue; } merged.push(a); used[i]=true; for(let j=i+1;j<dets.length;j++){ if(used[j]) continue; const b=dets[j]; const d=Math.hypot(a.x-b.x,a.y-b.y); const thr=Math.min(Math.max(a.r1,a.r2),Math.max(b.r1,b.r2))*0.48; if(d<thr) used[j]=true; } }
  const zones=lockedZones(performance.now()); let mergedFiltered=merged.filter(o=>!insideAnyZone(o.x,o.y,zones));

  // memory-based spawns
  decayMemory(); for(const a of mergedFiltered){ depositMemory(a.x/sX, a.y/sY); } const sp=spawnFromMemory(); for(const p of sp){ const Rv=sizePrior.R||12; mergedFiltered.push({type:'circle',x:p.cx*sX,y:p.cy*sY,r1:Rv,r2:Rv,a:0,score:0.9,strong:true}); }

  assignTracks(mergedFiltered);

  // dedupe tracks (keep most stable)
  (function(){ const keep=[]; const sorted=[...tracker.tracks].sort((a,b)=>((b.lockedUntil||0)-(a.lockedUntil||0))||((b.okHoldUntil||0)-(a.okHoldUntil||0))||((b.age||0)-(a.age||0))); for(const t of sorted){ let dup=false; for(const k of keep){ const d=Math.hypot(t.x-k.x,t.y-k.y); const thr=Math.min(Math.max(t.r1||12,t.r2||12),Math.max(k.r1||12,k.r2||12))*0.60; if(d<thr){ dup=true; break; } } if(!dup) keep.push(t); } tracker.tracks=keep; })();
  tracker.tracks=tracker.tracks.filter(t=>{ const big=Math.max(t.r1||12,t.r2||12), small=Math.min(t.r1||12,t.r2||12); return big<=maxR*1.2 && small>=minR*0.5; });

  // draw + count
  octx.clearRect(0,0,overlay.width,overlay.height); octx.lineWidth=3; const now=performance.now(); let okCount=0; for(const t of tracker.tracks){ const ok=(t.lockedUntil && now<t.lockedUntil) || (t.okSince && now<(t.okHoldUntil||0)); if(ok) okCount++; octx.strokeStyle= ok? 'rgba(0,200,0,0.98)' : 'rgba(255,165,0,0.9)'; octx.fillStyle= ok? 'rgba(255,0,0,0.98)' : 'rgba(255,165,0,0.95)'; if(t.type==='ellipse' && Math.abs(t.r1-t.r2)>1){ octx.beginPath(); octx.ellipse(t.x,t.y,Math.max(6,t.r1),Math.max(6,t.r2),t.a,0,Math.PI*2); octx.stroke(); } else { octx.beginPath(); octx.arc(t.x,t.y,Math.max(6,t.r1),0,Math.PI*2); octx.stroke(); } octx.beginPath(); octx.arc(t.x,t.y,4,0,Math.PI*2); octx.fill(); }
  countEl.textContent=String(okCount);

  // finalize if stable or deadline
  (function(){ const elapsed=performance.now()-startTs; process._hist=process._hist||[]; process._hist.push(okCount); if(process._hist.length>STABLE_WIN) process._hist.shift(); const min=Math.min(...process._hist), max=Math.max(...process._hist); if(!frozen && ((process._hist.length>=STABLE_WIN && (max-min)<=STABLE_TOL && elapsed>1200) || elapsed>=DEADLINE_MS)){ freezeNow(Math.round(median(process._hist))); } })();

  finalMask.delete(); updateFps(); frameIdx++;
}catch(e){ console.error(e); showErr(e?.message||String(e)); }
  requestAnimationFrame(process);
}

window.cv=window.cv||{}; cv.onRuntimeInitialized=()=>{ startBtn.disabled=false; };

// Soft refresh: reset detection without restarting camera (keeps size stable)
function softRefreshDetection(){
  frozen=false; running=true; startTs=performance.now();
  process._hist=[]; frameIdx=0; countEl.textContent='0';
  tracker.tracks=[]; tracker.nextId=1; sizePrior.R=null;
  try{ cache.grad&&cache.grad.delete(); cache.grad=null; cache.gradBin&&cache.gradBin.delete(); cache.gradBin=null; cache.dtMask&&cache.dtMask.delete(); cache.dtMask=null; cache.labMask&&cache.labMask.delete(); cache.labMask=null; cache.lcMask&&cache.lcMask.delete(); cache.lcMask=null; cache.glare&&cache.glare.delete(); cache.glare=null; }catch{}
  try{ mem.cells&&mem.cells.fill(0); }catch{}
  requestAnimationFrame(process);
}

// Lock/unlock feed size to avoid shrink-jump during camera restarts on iPhone
function lockFeedSize(){ const feed=document.querySelector('.feed'); if(!feed) return; const rect=feed.getBoundingClientRect(); const h=rect.height||video.getBoundingClientRect().height||0; feed.style.setProperty('--locked-h', `${Math.round(h)}px`); feed.classList.add('lock'); }
function unlockFeedSize(){ const feed=document.querySelector('.feed'); if(!feed) return; feed.classList.remove('lock'); feed.style.removeProperty('--locked-h'); }

function startAutoRefresh(){ try{ clearInterval(autoRefreshTimer); }catch{} autoRefreshTimer=setInterval(()=>{ if(running&&stream){ softRefreshDetection(); } }, DETECTION_REFRESH_MS); }

startBtn.addEventListener('click', async()=>{
  startBtn.disabled=true; const ok=await startCamera(); if(ok){ const ready=()=>{ syncBuffers(); running=true; frozen=false; startTs=performance.now(); process._hist=[]; requestAnimationFrame(process); startAutoRefresh(); }; if(video.readyState>=1) ready(); else video.addEventListener('loadedmetadata', ready, {once:true}); } else { showErr('Could not start the camera.'); } startBtn.disabled=false; });
window.addEventListener('resize', ()=>{ if(video.videoWidth) syncBuffers(); });

// Brightness slider -> try hardware exposure first; fallback to software "beta"
brightEl.addEventListener('input', ()=>{
  userBright = Number(brightEl.value) | 0; brightVal.textContent = userBright;
  // Try to map to hardware exposureCompensation if supported
  try{
    if(stream){ const track = stream.getVideoTracks()[0]; const caps = track.getCapabilities ? track.getCapabilities() : {}; if(caps.exposureCompensation){ const min=caps.exposureCompensation.min, max=caps.exposureCompensation.max; const mapped = min + (max-min) * ((userBright+60)/120); track.applyConstraints({ advanced:[{ exposureCompensation: mapped }] }).catch(()=>{}); }
    }
  }catch{}
});

function resetAll(){ tracker.tracks=[]; tracker.nextId=1; sizePrior.R=null; frameIdx=0; process._hist=[]; octx.clearRect(0,0,overlay.width,overlay.height); countEl.textContent='…'; try{ cache.grad&&cache.grad.delete(); cache.grad=null; cache.gradBin&&cache.gradBin.delete(); cache.gradBin=null; cache.dtMask&&cache.dtMask.delete(); cache.dtMask=null; cache.labMask&&cache.labMask.delete(); cache.labMask=null; cache.lcMask&&cache.lcMask.delete(); cache.lcMask=null; cache.glare&&cache.glare.delete(); cache.glare=null; }catch{} mem.cells&&mem.cells.fill(0); }
async function refreshCamera(){
  lockFeedSize();
  running=false; frozen=false;
  try{ if(stream){ stream.getTracks().forEach(t=>t.stop()); } }catch{}
  stream=null; resetAll(); startBtn.disabled=true;
  const ok=await startCamera();
  if(ok){ syncBuffers(); running=true; frozen=false; startTs=performance.now(); requestAnimationFrame(process); startAutoRefresh(); setTimeout(unlockFeedSize, 300); }
  else { unlockFeedSize(); }
  startBtn.disabled=false;
} }catch{} stream=null; resetAll(); startBtn.disabled=true; const ok=await startCamera(); if(ok){ syncBuffers(); running=true; frozen=false; startTs=performance.now(); requestAnimationFrame(process); } startBtn.disabled=false; }
recountBtn.addEventListener('click', refreshCamera);

window.addEventListener('beforeunload', ()=>{ try{stream&&stream.getTracks().forEach(t=>t.stop());}catch{}; [src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt,glareMask,contours,hierarchy,kSmall,kBig,clahe,sobelX,sobelY,absX,absY,grad,gradBin].forEach(m=>{try{m&&m.delete()}catch{}}); try{ cache.grad&&cache.grad.delete(); cache.gradBin&&cache.gradBin.delete(); cache.dtMask&&cache.dtMask.delete(); }catch{} try{ clearInterval(autoRefreshTimer);}catch{} }); cache.grad&&cache.grad.delete(); cache.gradBin&&cache.grad.delete(); cache.dtMask&&cache.dtMask.delete(); });
</script>
</body>
</html>
