<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lexieye â€“ Live Pill Counter (Realâ€‘time, Robust)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--primary:#007acc;--accent:#d9eaff;--bg:#fdfefe;--glass:rgba(255,255,255,0.2);--border-glass:rgba(255,255,255,0.4);--text:#333}
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.4rem; color:var(--primary); margin:0 0 16px }
    .wrap{ max-width:1000px; margin:auto; border-radius:28px; padding:20px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(30px) }
    .row{ display:grid; grid-template-columns:1fr; gap:12px }
    video,canvas{ width:100%; border-radius:18px; border:2px solid var(--primary) }
    .controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:12px }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:20px; padding:10px 16px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .label{ font-size:.95rem }
    .count{ font-weight:700 }
    .err{ color:#b00020; font-size:.95rem }
    .pill{ display:inline-block; padding:2px 6px; border-radius:12px; background:#e8f4ff; border:1px solid #cfe7ff }
    select, input[type="range"], input[type="number"]{ padding:6px 8px; border-radius:10px; border:1px solid #bcd6ef }
  </style>
</head>
<body>
  <h1>ðŸ’Š Lexieye â€“ Live Pill Counter</h1>

  <div class="wrap">
    <div class="controls">
      <button id="startBtn" class="btn">Enable Camera</button>
      <button id="toggleBtn" class="btn" disabled>Start Live Count</button>
      <span>Detected: <span id="count" class="count pill">0</span></span>
      <span id="fps" title="frames per second" class="pill">0 fps</span>
    </div>
    <div class="err" id="err"></div>

    <div class="row">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
      <span class="label">Mode</span>
      <select id="mode">
        <option value="contours">Contours (fast)</option>
        <option value="hough">Hough Circles (round tablets)</option>
        <option value="watershed">Watershed (split touching)</option>
      </select>

      <label class="label">Min size % of frame
        <input type="number" id="minPct" value="0.02" step="0.005" min="0.001" max="0.2" style="width:80px"/>
      </label>
      <label class="label">Max size % of frame
        <input type="number" id="maxPct" value="0.20" step="0.01" min="0.02" max="0.9" style="width:80px"/>
      </label>

      <label class="label">Invert
        <input type="checkbox" id="invert" checked />
      </label>
      <label class="label">CLAHE (contrast)
        <input type="checkbox" id="claheOn" checked />
      </label>
      <label class="label">Split touching
        <input type="checkbox" id="splitOn" />
      </label>
      <label class="label">Show debug
        <select id="debug">
          <option value="none">None</option>
          <option value="thresh">Threshold</option>
          <option value="morph">Morph</option>
          <option value="dt">Distance</option>
          <option value="markers">Markers</option>
        </select>
      </label>
    </div>
  </div>

  <script>
    // --- UI refs ---
    const startBtn = document.getElementById('startBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const errEl = document.getElementById('err');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx2d = canvas.getContext('2d');
    const countEl = document.getElementById('count');
    const fpsEl = document.getElementById('fps');

    const modeEl = document.getElementById('mode');
    const minPctEl = document.getElementById('minPct');
    const maxPctEl = document.getElementById('maxPct');
    const invertEl = document.getElementById('invert');
    const claheOnEl = document.getElementById('claheOn');
    const splitOnEl = document.getElementById('splitOn');
    const debugEl = document.getElementById('debug');

    let stream=null, running=false, lastTick=performance.now(), frames=0;

    // OpenCV mats
    let src, rgba, gray, blur, thresh, morph, kernel, contours, hierarchy;
    let clahe = null, dt = null, markers = null, three = null; // watershed helpers

    function showErr(msg){ errEl.textContent = msg; console.error(msg); }

    function secureContextCheck(){
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1'){
        showErr('Camera requires HTTPS or localhost. Host over HTTPS or use a local dev server.');
      }
    }

    async function startCamera(){
      errEl.textContent = '';
      const tries = [
        { video: { facingMode: { ideal: 'environment' }, width:{ideal:1280}, height:{ideal:720} }, audio:false },
        { video: true, audio: false }
      ];
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const back = devices.find(d => d.kind==='videoinput' && /back|environment/i.test(d.label||''));
        if (back) tries.unshift({ video: { deviceId: { exact: back.deviceId } }, audio:false });
      } catch {}

      for (const c of tries){
        try {
          stream = await navigator.mediaDevices.getUserMedia(c);
          video.srcObject = stream; video.setAttribute('playsinline','true'); await video.play();
          return true;
        } catch(e){
          console.warn('gUM failure', c, e);
          if (e.name==='NotAllowedError') showErr('Camera permission denied. Allow access and reload.');
          if (e.name==='NotFoundError') showErr('No camera found.');
        }
      }
      showErr('Could not start the camera.');
      return false;
    }

    function initMats(w,h){
      // clean existing
      [src, rgba, gray, blur, thresh, morph, kernel, contours, hierarchy, dt, markers, three].forEach(m=>{ try{ m&&m.delete(); }catch{} });
      if (clahe){ try{ clahe.delete(); }catch{}; clahe=null; }

      src = new cv.Mat(h, w, cv.CV_8UC4);
      rgba= new cv.Mat(h, w, cv.CV_8UC3);
      gray= new cv.Mat(h, w, cv.CV_8UC1);
      blur= new cv.Mat(h, w, cv.CV_8UC1);
      thresh=new cv.Mat(h, w, cv.CV_8UC1);
      morph=new cv.Mat(h, w, cv.CV_8UC1);
      kernel=cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
      contours=new cv.MatVector();
      hierarchy=new cv.Mat();
      dt = new cv.Mat();
      markers = new cv.Mat();
      three = new cv.Mat(h, w, cv.CV_8UC3);
      try { clahe = cv.createCLAHE(2.0, new cv.Size(8,8)); } catch { clahe = null; }
    }

    function percentToArea(px, py, pct){
      // approximate as percentage of total pixels
      const total = px*py; return Math.max(1, Math.round(total * pct));
    }

    function updateFps(){
      frames++;
      const now = performance.now();
      if (now - lastTick >= 1000){
        fpsEl.textContent = `${frames} fps`;
        frames = 0; lastTick = now;
      }
    }

    function processFrame(){
      if (!running) return;
      const w = video.videoWidth||640, h = video.videoHeight||480;
      if (!src || src.cols!==w || src.rows!==h){ canvas.width=w; canvas.height=h; initMats(w,h); }

      ctx2d.drawImage(video, 0, 0, w, h);
      cv.imread(canvas, src);
      cv.cvtColor(src, rgba, cv.COLOR_RGBA2RGB);
      cv.cvtColor(rgba, gray, cv.COLOR_RGB2GRAY);

      // Contrast / illumination fix
      if (claheOnEl.checked && clahe){ clahe.apply(gray, gray); }

      // Smoothing
      cv.medianBlur(gray, blur, 3);

      // Threshold (Otsu). Invert if pills are bright on dark.
      const flag = (invertEl.checked ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY) + cv.THRESH_OTSU;
      cv.threshold(blur, thresh, 0, 255, flag);

      // Morph cleanup
      cv.morphologyEx(thresh, morph, cv.MORPH_OPEN, kernel);
      cv.morphologyEx(morph, morph, cv.MORPH_CLOSE, kernel);

      const minArea = percentToArea(w,h, parseFloat(minPctEl.value)||0.02);
      const maxArea = percentToArea(w,h, parseFloat(maxPctEl.value)||0.2);

      let count = 0;

      const mode = modeEl.value;

      if (mode === 'hough'){
        // good for round tablets
        const circles = new cv.Mat();
        try {
          cv.HoughCircles(blur, circles, cv.HOUGH_GRADIENT, 1, 20, 120, 25, 6, Math.floor(Math.min(w,h)*0.2));
          for (let i=0; i<circles.cols; i++){
            const x = circles.data32F[i*3], y = circles.data32F[i*3+1], r = circles.data32F[i*3+2];
            const a = Math.PI*r*r;
            if (a>=minArea && a<=maxArea){
              cv.circle(rgba, new cv.Point(x,y), r, [0,255,0,255], 3);
              count++;
            }
          }
        } finally { circles.delete(); }
      }
      else if (mode === 'watershed' || splitOnEl.checked){
        // Split touching objects with watershed
        // Distance transform for foreground
        cv.distanceTransform(morph, dt, cv.DIST_L2, 3);
        // Normalize for visualization and thresholding
        const dtNorm = new cv.Mat();
        cv.normalize(dt, dtNorm, 0, 1.0, cv.NORM_MINMAX);
        const dt8 = new cv.Mat();
        dtNorm.convertTo(dt8, cv.CV_8U, 255);

        // Sure foreground
        const dtThresh = new cv.Mat();
        cv.threshold(dtNorm, dtThresh, 0.35, 1.0, cv.THRESH_BINARY);
        dtThresh.convertTo(dt8, cv.CV_8U, 255);

        // Sure background
        const bg = new cv.Mat();
        cv.dilate(morph, bg, kernel);

        // Markers
        const markers32 = new cv.Mat();
        cv.subtract(bg, dt8, markers);
        // Connected components on fg
        const comps = new cv.Mat();
        const nLabels = cv.connectedComponents(dt8, comps);
        comps.convertTo(markers32, cv.CV_32S);

        // Watershed needs 3â€‘channel input
        cv.cvtColor(rgba, three, cv.COLOR_RGB2BGR);
        cv.watershed(three, markers32);

        // Count unique labels > 1 and draw contours
        const labelMask = new cv.Mat(h, w, cv.CV_8U, new cv.Scalar(0));
        // Iterate over labels; we draw boundaries from markers32
        // Extract contours on morph (clean mask) and filter by area
        cv.findContours(morph, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        for (let i=0;i<contours.size();i++){
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area>=minArea && area<=maxArea){
            const M = cv.moments(cnt);
            const cx = M.m10/(M.m00||1), cy = M.m01/(M.m00||1);
            const r = Math.max(4, Math.sqrt(area/Math.PI)|0);
            cv.circle(rgba, new cv.Point(cx,cy), r, [0,255,0,255], 3);
            count++;
          }
          cnt.delete();
        }
        // Cleanup
        dtNorm.delete(); dt8.delete(); dtThresh.delete(); bg.delete(); comps.delete(); markers32.delete(); labelMask.delete();
      }
      else { // contours (fast)
        cv.findContours(morph, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        for (let i=0;i<contours.size();i++){
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area<minArea || area>maxArea){ cnt.delete(); continue; }
          const peri = cv.arcLength(cnt, true);
          const circ = (4*Math.PI*area)/(peri*peri + 1e-6);
          // accept most convex-ish shapes (capsules)
          const hull = new cv.Mat(); cv.convexHull(cnt, hull);
          const solid = area / Math.max(cv.contourArea(hull),1e-6);
          if (circ>=0.5 && solid>=0.8){
            const M = cv.moments(cnt);
            const cx = M.m10/(M.m00||1), cy = M.m01/(M.m00||1);
            const r = Math.max(4, Math.sqrt(area/Math.PI)|0);
            cv.circle(rgba, new cv.Point(cx,cy), r, [0,255,0,255], 3);
            count++;
          }
          hull.delete(); cnt.delete();
        }
      }

      // Debug views
      switch (debugEl.value){
        case 'thresh': cv.imshow(canvas, thresh); break;
        case 'morph':  cv.imshow(canvas, morph);  break;
        case 'dt':     if (!dt.empty()) cv.imshow(canvas, dt); else cv.imshow(canvas, rgba); break;
        default:
          cv.imshow(canvas, rgba); break;
      }

      countEl.textContent = count;
      updateFps();
      requestAnimationFrame(processFrame);
    }

    function setRunning(on){
      running = on; toggleBtn.textContent = on ? 'Stop Live Count' : 'Start Live Count';
      if (on) requestAnimationFrame(processFrame);
    }

    // UI events
    startBtn.addEventListener('click', async () => {
      secureContextCheck();
      const ok = await startCamera();
      if (ok){ toggleBtn.disabled=false; startBtn.disabled=true; }
    });
    toggleBtn.addEventListener('click', ()=> setRunning(!running));

    // OpenCV ready gate
    window.cv = window.cv || {};
    cv['onRuntimeInitialized'] = () => { console.log('OpenCV ready'); };

    // Cleanup
    window.addEventListener('beforeunload', () => {
      try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch{}
      [src, rgba, gray, blur, thresh, morph, kernel, contours, hierarchy, dt, markers, three].forEach(m=>{ try{ m&&m.delete(); }catch{} });
      if (clahe){ try{ clahe.delete(); }catch{} }
    });

    // initial https check
    secureContextCheck();
  </script>
</body>
</html>
