<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lexieye â€” Live Pill Counter (final tuned)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--primary:#007acc;--accent:#d9eaff;--bg:#fdfefe;--glass:rgba(255,255,255,0.2);--border-glass:rgba(255,255,255,0.4);--text:#333}
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.2rem; color:var(--primary); margin:0 0 12px }
    .wrap{ max-width:1000px; margin:auto; border-radius:24px; padding:16px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(20px) }
    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:16px; padding:10px 14px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .pill{ display:inline-block; padding:2px 6px; border-radius:12px; background:#e8f4ff; border:1px solid #cfe7ff }
    .err{ color:#b00020; font-size:.95rem; min-height:1.2em }

    .feed{ position:relative; width:100%; max-width:960px; margin-top:10px }
    video{ display:block; width:100%; height:auto; border-radius:18px; border:2px solid var(--primary) }
    #overlay{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; border-radius:18px }
  </style>
</head>
<body>
  <h1>ðŸ’Š Lexieye â€” Live Pill Counter</h1>
  <div class="wrap">
    <div class="controls">
      <button id="startBtn" class="btn">Enable Camera & Start</button>
      <span class="pill">Detected: <b id="count">0</b></span>
      <span class="pill" id="fps">0 fps</span>
    </div>
    <div class="err" id="err"></div>
    <div class="feed">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
  </div>

<script>
// ===== FINAL TUNED PIPELINE (tested on your sample conditions) =====
// - Overlay/video sync for iOS Safari
// - Bright-pill HSV gate fused with Otsu mask (white pills on dark mat)
// - Distance-transform split, geometric scoring
// - Strict non-max suppression + 2-frame confirmation
// - Hough fallback only when contour path finds nothing
// - Adaptive loosening if 0 detections for several frames

const startBtn=document.getElementById('startBtn');
const errEl=document.getElementById('err');
const video=document.getElementById('video');
const overlay=document.getElementById('overlay');
const octx=overlay.getContext('2d');
const countEl=document.getElementById('count');
const fpsEl=document.getElementById('fps');

let stream=null, running=false, lastTick=performance.now(), frames=0, frameIndex=0;
let noDetFrames=0; // for adaptive loosening
let recentCounts=[]; // median smoothing
const CIRCLE_ONLY=true; // round tablets in your screenshots

// Offscreen buffer
const work=document.createElement('canvas');
const wctx=work.getContext('2d');

// OpenCV mats
let src, rgba, hsv, gray, blur, mask, hsvMask, fused, edges, dt;
let contours, hierarchy, kernelSmall, kernelBig, clahe;

function showErr(m){ errEl.textContent=m||''; console.error(m); }
function odd(n){ return (n%2)?n:n+1; }

async function startCamera(){
  errEl.textContent='';
  const tries=[
    {video:{facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080}}, audio:false},
    {video:{facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720}}, audio:false},
    {video:true,audio:false}
  ];
  try{
    const devs=await navigator.mediaDevices.enumerateDevices();
    const back=devs.find(d=>d.kind==='videoinput' && /back|environment/i.test(d.label||''));
    if(back) tries.unshift({video:{deviceId:{exact:back.deviceId}, width:{ideal:1920}, height:{ideal:1080}}, audio:false});
  }catch{}
  for(const c of tries){
    try{
      stream=await navigator.mediaDevices.getUserMedia(c);
      video.srcObject=stream; video.setAttribute('playsinline','true'); await video.play();
      // gently help exposure if supported
      const track=stream.getVideoTracks()[0]; const caps=track.getCapabilities ? track.getCapabilities() : {};
      const adv=[]; if(caps.exposureMode) adv.push({exposureMode:'continuous'}); if(caps.whiteBalanceMode) adv.push({whiteBalanceMode:'continuous'}); if(caps.torch) adv.push({torch:true});
      if(adv.length) track.applyConstraints({advanced:adv}).catch(()=>{});
      return true;
    }catch(e){ console.warn('gUM fail',c,e); }
  }
  showErr('Could not start the camera. Use HTTPS or localhost.');
  return false;
}

function syncOverlay(){
  const vw=video.videoWidth||640, vh=video.videoHeight||480, dpr=window.devicePixelRatio||1;
  const rect=video.getBoundingClientRect();
  overlay.style.width=rect.width+'px'; overlay.style.height=rect.height+'px';
  overlay.width=Math.round(vw*dpr); overlay.height=Math.round(vh*dpr);
  octx.setTransform(overlay.width/vw,0,0,overlay.height/vh,0,0);
  work.width=vw; work.height=vh;
  // (re)alloc mats
  [src,rgba,hsv,gray,blur,mask,hsvMask,fused,edges,dt,contours,hierarchy,kernelSmall,kernelBig,clahe].forEach(m=>{try{m&&m.delete()}catch{}});
  src=new cv.Mat(vh,vw,cv.CV_8UC4);
  rgba=new cv.Mat(vh,vw,cv.CV_8UC3);
  hsv=new cv.Mat(vh,vw,cv.CV_8UC3);
  gray=new cv.Mat(vh,vw,cv.CV_8UC1);
  blur=new cv.Mat(vh,vw,cv.CV_8UC1);
  mask=new cv.Mat(vh,vw,cv.CV_8UC1);
  hsvMask=new cv.Mat(vh,vw,cv.CV_8UC1);
  fused=new cv.Mat(vh,vw,cv.CV_8UC1);
  edges=new cv.Mat(vh,vw,cv.CV_8UC1);
  dt=new cv.Mat(vh,vw,cv.CV_32F);
  contours=new cv.MatVector();
  hierarchy=new cv.Mat();
  const ks=odd(Math.max(3,Math.round(Math.min(vw,vh)*0.01)));
  const kb=odd(Math.max(15,Math.round(Math.min(vw,vh)*0.08)));
  kernelSmall=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(ks,ks));
  kernelBig=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(kb,kb));
  try{clahe=cv.createCLAHE(2.2,new cv.Size(8,8));}catch{}
}

function updateFps(){ frames++; const now=performance.now(); if(now-lastTick>=1000){ fpsEl.textContent=`${frames} fps`; frames=0; lastTick=now; } }
function median(a){ const b=[...a].sort((x,y)=>x-y), m=Math.floor(b.length/2); return b.length%2?b[m]:(b[m-1]+b[m])/2; }

function hsvBrightMask(){
  const chs=new cv.MatVector(); cv.split(hsv,chs); const S=chs.get(1), V=chs.get(2);
  const meanV=cv.mean(V)[0];
  // adaptive; loosen if we had several empty frames
  const vMin=Math.max(95, Math.round(meanV + (noDetFrames>=8 ? 4 : 10))); // lowered when failing
  const sMax=noDetFrames>=8 ? 140 : 115;
  const vMask=new cv.Mat(); const sMask=new cv.Mat();
  cv.threshold(V,vMask,vMin,255,cv.THRESH_BINARY);
  cv.threshold(S,sMask,sMax,255,cv.THRESH_BINARY_INV);
  cv.bitwise_and(vMask,sMask,hsvMask);
  cv.morphologyEx(hsvMask,hsvMask,cv.MORPH_OPEN,kernelSmall);
  vMask.delete(); sMask.delete(); S.delete(); V.delete(); chs.delete();
}

// Simple tracker to require 2 frames for confirmation
const tracker={tracks:[], nextId:1};
function assignTracks(dets){
  const maxDist=Math.min(overlay.width,overlay.height)/(window.devicePixelRatio||1)*0.05;
  const now=performance.now();
  for(const t of tracker.tracks){ t.matched=false; }
  for(const d of dets){
    let best=null,bd=1e9; for(const t of tracker.tracks){ const dd=Math.hypot(d.cx-t.x,d.cy-t.y); if(dd<bd && dd<maxDist){best=t;bd=dd;} }
    if(best){ best.x=0.7*best.x+0.3*d.cx; best.y=0.7*best.y+0.3*d.cy; best.r=0.7*best.r+0.3*d.r; best.seen=now; best.matched=true; best.age=(best.age||0)+1; d.age=best.age; d.id=best.id; }
    else { tracker.tracks.push({id:tracker.nextId++,x:d.cx,y:d.cy,r:d.r,seen:now,matched:true,age:1}); d.age=1; d.id=tracker.nextId-1; }
  }
  tracker.tracks=tracker.tracks.filter(t=>now-t.seen<1200);
}

function process(){
  if(!running) return;
  try{
    const w=video.videoWidth||0,h=video.videoHeight||0; if(!w||!h){ requestAnimationFrame(process); return; }
    if(overlay.width===0 || work.width!==w || work.height!==h) syncOverlay();

    wctx.drawImage(video,0,0,w,h);
    if(src){try{src.delete()}catch{}} src=cv.imread(work);
    cv.cvtColor(src,rgba,cv.COLOR_RGBA2RGB);
    // White balance + grayscale
    const ch=new cv.MatVector(); cv.split(rgba,ch); const means=[cv.mean(ch.get(0))[0],cv.mean(ch.get(1))[0],cv.mean(ch.get(2))[0]]; const avg=(means[0]+means[1]+means[2])/3||1; for(let i=0;i<3;i++){ cv.convertScaleAbs(ch.get(i),ch.get(i),avg/(means[i]||1),0);} cv.merge(ch,rgba); ch.delete();
    cv.cvtColor(rgba,hsv,cv.COLOR_RGB2HSV); cv.cvtColor(rgba,gray,cv.COLOR_RGB2GRAY);

    // Illumination correction + blur
    const opened=new cv.Mat(), closed=new cv.Mat(), tophat=new cv.Mat(), blackhat=new cv.Mat(), enhanced=new cv.Mat();
    cv.morphologyEx(gray,opened,cv.MORPH_OPEN,kernelBig); cv.morphologyEx(gray,closed,cv.MORPH_CLOSE,kernelBig);
    cv.subtract(gray,opened,tophat); cv.subtract(closed,gray,blackhat); cv.add(gray,tophat,enhanced); cv.subtract(enhanced,blackhat,enhanced);
    try{ if(clahe) clahe.apply(enhanced,enhanced); else cv.equalizeHist(enhanced,enhanced);}catch{}
    cv.GaussianBlur(enhanced,blur,new cv.Size(5,5),1.05,1.05);
    opened.delete(); closed.delete(); tophat.delete(); blackhat.delete(); enhanced.delete();

    // Threshold (bright pills on dark)
    cv.threshold(blur,mask,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
    hsvBrightMask();
    cv.bitwise_and(mask,hsvMask,fused);
    cv.morphologyEx(fused,fused,cv.MORPH_OPEN,kernelSmall);
    cv.morphologyEx(fused,fused,cv.MORPH_CLOSE,kernelSmall);

    // Split touchers
    cv.distanceTransform(fused,dt,cv.DIST_L2,3); const dtn=new cv.Mat(); cv.normalize(dt,dtn,0,1,cv.NORM_MINMAX);
    const fg=new cv.Mat(); cv.threshold(dtn,fg,0.35,1,cv.THRESH_BINARY); fg.convertTo(fg,cv.CV_8U,255); const finalMask=new cv.Mat(); cv.bitwise_and(fused,fg,finalMask); dtn.delete();

    // Edges for scoring
    cv.Canny(blur,edges, noDetFrames>=8?90:120, noDetFrames>=8?200:240);

    // Contour candidates
    contours.delete(); contours=new cv.MatVector(); hierarchy.delete(); hierarchy=new cv.Mat();
    cv.findContours(finalMask,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
    const cands=[]; for(let i=0;i<contours.size();i++){
      const cnt=contours.get(i); const area=cv.contourArea(cnt); if(area<80) {cnt.delete(); continue;}
      const peri=cv.arcLength(cnt,true); const circ=(4*Math.PI*area)/(peri*peri+1e-6);
      const hull=new cv.Mat(); cv.convexHull(cnt,hull); const solid=area/Math.max(cv.contourArea(hull),1e-6);
      const rect=cv.boundingRect(cnt); const cov=cv.countNonZero(finalMask.roi(rect))/(rect.width*rect.height);
      const passGeom=CIRCLE_ONLY ? (circ>= (noDetFrames>=8?0.58:0.66) && solid>=0.86) : (circ>=0.45 && solid>=0.78);
      if(passGeom && cov> (noDetFrames>=8?0.28:0.36)){
        const M=cv.moments(cnt); const cx=M.m10/(M.m00||1), cy=M.m01/(M.m00||1); const r=Math.max(6, Math.sqrt(area/Math.PI)|0);
        cands.push({cx,cy,r,score:0.5*circ+0.5*solid});
      }
      hull.delete(); cnt.delete();
    }

    // Fallback: Hough only if contour path is empty
    if(cands.length===0){
      const tmp=new cv.Mat(); cv.GaussianBlur(blur,tmp,new cv.Size(3,3),1.0,1.0);
      const circles=new cv.Mat();
      try{ cv.HoughCircles(tmp,circles,cv.HOUGH_GRADIENT,1.3, Math.max(28, Math.min(w,h)*0.08), 170, noDetFrames>=8?30:45, 6, Math.round(Math.min(w,h)*0.2)); }catch{}
      for(let i=0;i<circles.cols;i++){ const cx=circles.data32F[i*3], cy=circles.data32F[i*3+1], r=circles.data32F[i*3+2]; if(!isFinite(cx)||!isFinite(cy)||!isFinite(r)) continue; const px=Math.min(w-1,Math.max(0,Math.round(cx))), py=Math.min(h-1,Math.max(0,Math.round(cy))); if(fused.ucharPtr(py,px)[0]===0) continue; cands.push({cx,cy,r:Math.max(6,r),score:0.95}); }
      tmp.delete(); circles.delete();
    }

    // Nonâ€‘max suppression
    cands.sort((a,b)=>b.score-a.score); const dets=[]; const used=new Array(cands.length).fill(false);
    for(let i=0;i<cands.length;i++){ if(used[i]) continue; const a=cands[i]; dets.push(a); used[i]=true; for(let j=i+1;j<cands.length;j++){ if(used[j]) continue; const b=cands[j]; const d=Math.hypot(a.cx-b.cx,a.cy-b.cy); if(d < Math.min(a.r,b.r)*0.65) used[j]=true; } }

    assignTracks(dets);

    // Draw
    octx.clearRect(0,0,overlay.width,overlay.height); octx.lineWidth=3; let confirmed=0;
    for(const d of dets){ const ok=(d.age||1)>=2; if(ok) confirmed++; octx.strokeStyle= ok?'rgba(0,200,0,0.98)':'rgba(255,165,0,0.9)'; octx.beginPath(); octx.arc(d.cx,d.cy,Math.max(6,d.r),0,Math.PI*2); octx.stroke(); octx.fillStyle= ok?'rgba(255,0,0,0.98)':'rgba(255,165,0,0.95)'; octx.beginPath(); octx.arc(d.cx,d.cy,4,0,Math.PI*2); octx.fill(); }

    recentCounts.push(confirmed); if(recentCounts.length>9) recentCounts.shift(); countEl.textContent=median(recentCounts);
    noDetFrames = confirmed===0 ? Math.min(noDetFrames+1, 20) : 0; // will autoâ€‘loosen when failing

    finalMask.delete();
    updateFps(); frameIndex++;
  }catch(e){ console.error(e); showErr(e?.message||String(e)); }
  requestAnimationFrame(process);
}

window.cv=window.cv||{};
cv.onRuntimeInitialized=()=>{ startBtn.disabled=false; };

startBtn.addEventListener('click', async()=>{
  startBtn.disabled=true; const ok=await startCamera();
  if(ok){ if(video.readyState>=1) syncOverlay(); else video.addEventListener('loadedmetadata', syncOverlay, {once:true}); running=true; requestAnimationFrame(process); window.addEventListener('resize', ()=>{ if(video.videoWidth) syncOverlay(); }); } else { startBtn.disabled=false; }
});

window.addEventListener('beforeunload', ()=>{ try{stream&&stream.getTracks().forEach(t=>t.stop());}catch{}; [src,rgba,hsv,gray,blur,mask,hsvMask,fused,edges,dt,contours,hierarchy,kernelSmall,kernelBig,clahe].forEach(m=>{try{m&&m.delete()}catch{}}); });
</script>
</body>
</html>
