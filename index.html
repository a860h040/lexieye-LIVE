<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lexieye â€“ Live Pill Counter (Camera-safe)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root { --primary:#007acc; --accent:#d9eaff; --bg:#fdfefe; --glass:rgba(255,255,255,0.2); --border-glass:rgba(255,255,255,0.4); --text:#333; }
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.2rem; color:var(--primary); margin:0 0 20px }
    .wrap{ max-width:960px; margin:auto; border-radius:28px; padding:24px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(30px) }
    video,canvas{ width:100%; border-radius:22px; border:2px solid var(--primary); margin-top:12px }
    .controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:12px }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:24px; padding:10px 18px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .count{ font-weight:700 }
    .err{ color:#b00020; font-size:.95rem }
  </style>
</head>
<body>
  <h1>ðŸ’Š Lexieye â€“ Live Pill Counter</h1>

  <div class="wrap">
    <div class="controls">
      <button id="startBtn" class="btn">Enable Camera</button>
      <button id="toggleBtn" class="btn" disabled>Start Live Count</button>
      <span>Detected Pills: <span id="count" class="count">0</span></span>
    </div>
    <div class="err" id="err"></div>

    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <script>
    // UI elements
    const startBtn = document.getElementById('startBtn');
    const toggleBtn = document.getElementById('toggleBtn');
    const errEl = document.getElementById('err');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx2d = canvas.getContext('2d');
    const countEl = document.getElementById('count');

    // OpenCV buffers
    let src, gray, blurred, thresh, morph, contours, hierarchy, kernel;
    let stream = null, running = false, lastProcess = 0;

    function showErr(msg){ errEl.textContent = msg; console.error(msg); }

    function secureContextCheck(){
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1'){
        showErr('Camera requires HTTPS or localhost. Please host this page over HTTPS or run with a local dev server.');
      }
    }

    async function startCamera(){
      errEl.textContent = '';
      // Prefer back camera but fall back gracefully
      const tries = [
        { video: { facingMode: { ideal: 'environment' } }, audio:false },
        { video: true, audio:false }
      ];

      // If we already have deviceId for back camera, try it first
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const back = devices.find(d => d.kind === 'videoinput' && /back|environment/i.test(d.label || ''));
        if (back) tries.unshift({ video: { deviceId: { exact: back.deviceId } }, audio:false });
      } catch { /* ignore */ }

      for (const constraints of tries){
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          video.setAttribute('playsinline','true'); // iOS
          await video.play(); // Safari needs explicit play()
          return true;
        } catch (e){
          // Continue to next constraints set
          console.warn('getUserMedia failed with', constraints, e);
          if (e.name === 'NotAllowedError') showErr('Camera permission denied. Allow camera access in your browser settings and reload.');
          if (e.name === 'NotFoundError') showErr('No camera found. If on desktop, connect a webcam; on mobile, use a supported browser.');
          if (e.name === 'OverconstrainedError') showErr('Requested camera constraints not available. Trying fallbackâ€¦');
        }
      }
      showErr('Could not start the camera. Check HTTPS, permissions, and OS privacy settings.');
      return false;
    }

    function initMats(w,h){
      [src, gray, blurred, thresh, morph, contours, hierarchy, kernel].forEach(m => { try{ m && m.delete(); }catch{} });
      src = new cv.Mat(h, w, cv.CV_8UC4);
      gray = new cv.Mat(h, w, cv.CV_8UC1);
      blurred = new cv.Mat(h, w, cv.CV_8UC1);
      thresh = new cv.Mat(h, w, cv.CV_8UC1);
      morph = new cv.Mat(h, w, cv.CV_8UC1);
      contours = new cv.MatVector();
      hierarchy = new cv.Mat();
      kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
    }

    function processFrame(){
      if (!running) return;
      const now = performance.now();
      if (now - lastProcess < 80){ requestAnimationFrame(processFrame); return; } // throttle ~12.5 fps
      lastProcess = now;

      const w = video.videoWidth || 640, h = video.videoHeight || 480;
      if (!src || src.cols !== w || src.rows !== h){
        canvas.width = w; canvas.height = h; initMats(w,h);
      }

      ctx2d.drawImage(video, 0, 0, w, h);
      cv.imread(canvas, src);

      // Preprocess
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, blurred, new cv.Size(5,5), 1.2, 1.2);
      cv.adaptiveThreshold(blurred, thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 11, 5);
      cv.morphologyEx(thresh, morph, cv.MORPH_OPEN, kernel);

      // Contours
      cv.findContours(morph, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let count = 0;
      for (let i=0; i<contours.size(); i++){
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if (area < 200 || area > 12000){ cnt.delete(); continue; }

        const perimeter = cv.arcLength(cnt, true);
        const circularity = (4*Math.PI*area) / (perimeter*perimeter + 1e-6);

        const hull = new cv.Mat();
        cv.convexHull(cnt, hull);
        const solid = area / Math.max(cv.contourArea(hull), 1e-6);

        if (circularity >= 0.55 && solid >= 0.80){
          const M = cv.moments(cnt);
          const cx = M.m10 / (M.m00 || 1), cy = M.m01 / (M.m00 || 1);
          const r = Math.max(4, Math.sqrt(area/Math.PI)|0);
          cv.circle(src, new cv.Point(cx, cy), r, [0,255,0,255], 3);
          count++;
        }
        hull.delete(); cnt.delete();
      }

      cv.imshow(canvas, src);
      countEl.textContent = count;
      requestAnimationFrame(processFrame);
    }

    function setRunning(on){
      running = on;
      toggleBtn.textContent = on ? 'Stop Live Count' : 'Start Live Count';
      if (on) requestAnimationFrame(processFrame);
    }

    // Start button (user gesture required on iOS/Safari)
    startBtn.addEventListener('click', async () => {
      errEl.textContent = '';
      // Check secure context first
      secureContextCheck();

      // If Permissions API exists, hint the user
      try {
        if (navigator.permissions?.query) {
          const p = await navigator.permissions.query({ name: 'camera' });
          if (p.state === 'denied') showErr('Camera permission is blocked. Please allow camera access in site settings and reload.');
        }
      } catch {}

      const ok = await startCamera();
      if (ok){
        toggleBtn.disabled = false;
        startBtn.disabled = true;
      }
    });

    toggleBtn.addEventListener('click', () => setRunning(!running));

    // OpenCV gate: donâ€™t enable UI until cv is ready
    window.cv = window.cv || {};
    cv['onRuntimeInitialized'] = () => {
      // Now OpenCV is ready; user must click "Enable Camera"
      console.log('OpenCV ready');
    };

    // Cleanup
    window.addEventListener('beforeunload', () => {
      try { stream && stream.getTracks().forEach(t => t.stop()); } catch {}
      [src, gray, blurred, thresh, morph, contours, hierarchy, kernel].forEach(m => { try{ m && m.delete(); }catch{} });
    });

    // Immediate HTTPS check
    secureContextCheck();
  </script>
</body>
</html>
