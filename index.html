<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lexieye â€“ Live Pill Counter (camera view + overlay)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--primary:#007acc;--accent:#d9eaff;--bg:#fdfefe;--glass:rgba(255,255,255,0.2);--border-glass:rgba(255,255,255,0.4);--text:#333}
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.4rem; color:var(--primary); margin:0 0 16px }
    .wrap{ max-width:1000px; margin:auto; border-radius:28px; padding:20px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(30px) }
    .controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:12px }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:20px; padding:10px 16px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .pill{ display:inline-block; padding:2px 6px; border-radius:12px; background:#e8f4ff; border:1px solid #cfe7ff }
    .err{ color:#b00020; font-size:.95rem }
    .feed{ position:relative; width:100%; }
    video{ width:100%; border-radius:18px; border:2px solid var(--primary); display:block }
    /* Transparent overlay just for drawings */
    #overlay{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; border-radius:18px; }
  </style>
</head>
<body>
  <h1>ðŸ’Š Lexieye â€“ Live Pill Counter</h1>

  <div class="wrap">
    <div class="controls">
      <button id="startBtn" class="btn">Enable Camera & Start</button>
      <span class="pill">Detected: <b id="count">0</b></span>
      <span class="pill" id="fps">0 fps</span>
    </div>
    <div class="err" id="err"></div>

    <!-- Camera view kept. Only the captured IMAGE layer is removed; we draw on a transparent overlay. -->
    <div class="feed">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
  </div>

  <script>
  // Live camera + overlay â€” ultraâ€‘accuracy pipeline: illumination correction, multiâ€‘mask fusion, watershed split,
  // ellipse scoring, + Hough circles union, temporal confirmation tracking, perâ€‘pill red dot + green ring.
  const startBtn=document.getElementById('startBtn');
  const errEl=document.getElementById('err');
  const video=document.getElementById('video');
  const overlay=document.getElementById('overlay');
  const octx=overlay.getContext('2d');
  const countEl=document.getElementById('count');
  const fpsEl=document.getElementById('fps');

  let stream=null, running=false, lastTick=performance.now(), frames=0, warmup=30, frameIndex=0;
  let recentCounts=[]; // median smoothing

  // Offscreen work canvas
  const work=document.createElement('canvas');
  const wctx=work.getContext('2d');

  // OpenCV Mats
  let src, rgba, hsv, gray, blur, mask, edges, kernelSmall, kernelBig, contours, hierarchy, dt;
  let clahe=null; // contrast enhancer

  function showErr(msg){ errEl.textContent=msg; console.error(msg); }
  function secureContextCheck(){
    if (location.protocol!=='https:' && location.hostname!=='localhost' && location.hostname!=='127.0.0.1'){
      showErr('Camera requires HTTPS or localhost.');
    }
  }

  async function startCamera(){
    errEl.textContent='';
    const tries=[
      {video:{facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080}}, audio:false},
      {video:{facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720}}, audio:false},
      {video:true, audio:false}
    ];
    try{
      const devs=await navigator.mediaDevices.enumerateDevices();
      const back=devs.find(d=>d.kind==='videoinput' && /back|environment/i.test(d.label||''));
      if(back) tries.unshift({video:{deviceId:{exact:back.deviceId}, width:{ideal:1920}, height:{ideal:1080}}, audio:false});
    }catch{}
    for(const c of tries){
      try{
        stream=await navigator.mediaDevices.getUserMedia(c);
        video.srcObject=stream; video.setAttribute('playsinline','true'); await video.play();

        // Exposure/white balance/torch if supported
        const track = stream.getVideoTracks()[0];
        const caps  = track.getCapabilities ? track.getCapabilities() : {};
        const adv = [];
        if (caps.exposureMode) adv.push({ exposureMode:'continuous' });
        if (caps.whiteBalanceMode) adv.push({ whiteBalanceMode:'continuous' });
        if (caps.exposureCompensation) adv.push({ exposureCompensation: caps.exposureCompensation.max });
        if (caps.torch) adv.push({ torch:true });
        if (adv.length) { track.applyConstraints({ advanced: adv }).catch(()=>{}); }
        return true;
      }catch(e){ console.warn('gUM fail',c,e); }
    }
    showErr('Could not start the camera.');
    return false;
  }

  function odd(n){ return (n % 2) ? n : n+1; }
  function initMats(w,h){
    [src,rgba,hsv,gray,blur,mask,edges,kernelSmall,kernelBig,contours,hierarchy,dt].forEach(m=>{ try{ m&&m.delete(); }catch{} });
    if (clahe){ try{ clahe.delete(); }catch{}; clahe=null; }
    src=new cv.Mat(h,w,cv.CV_8UC4);
    rgba=new cv.Mat(h,w,cv.CV_8UC3);
    hsv=new cv.Mat(h,w,cv.CV_8UC3);
    gray=new cv.Mat(h,w,cv.CV_8UC1);
    blur=new cv.Mat(h,w,cv.CV_8UC1);
    mask=new cv.Mat(h,w,cv.CV_8UC1);
    edges=new cv.Mat(h,w,cv.CV_8UC1);
    dt=new cv.Mat(h,w,cv.CV_32F);
    const ks = odd(Math.max(3, Math.round(Math.min(w,h)*0.01))); // local cleanup
    const kb = odd(Math.max(15, Math.round(Math.min(w,h)*0.08))); // shade removal / split
    kernelSmall=cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(ks,ks));
    kernelBig  =cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(kb,kb));
    contours=new cv.MatVector();
    hierarchy=new cv.Mat();
    try { clahe = cv.createCLAHE(2.4, new cv.Size(8,8)); } catch { clahe = null; }
  }

  // Simple tracker with confirmation
  const tracker = { nextId:1, tracks:[] };
  function assignTracks(dets){
    const maxDist = Math.min(overlay.width, overlay.height) / (window.devicePixelRatio||1) * 0.045; // tighter
    const now = performance.now();
    for(const t of tracker.tracks){ t.matched=false; }

    for(const d of dets){
      let best=null, bestDist=1e9;
      for(const t of tracker.tracks){
        const dist = Math.hypot(d.cx - t.x, d.cy - t.y);
        if (dist < bestDist && dist < maxDist) { best=t; bestDist=dist; }
      }
      if (best){
        best.x = 0.7*best.x + 0.3*d.cx; best.y = 0.7*best.y + 0.3*d.cy; best.r = 0.7*best.r + 0.3*d.r;
        best.seen = now; best.matched=true; best.age = (best.age||0)+1; d.id=best.id; d.age=best.age;
      } else {
        tracker.tracks.push({ id:tracker.nextId++, x:d.cx, y:d.cy, r:d.r, seen:now, matched:true, age:1 });
        d.id=tracker.nextId-1; d.age=1;
      }
    }
    tracker.tracks = tracker.tracks.filter(t => now - t.seen < 1000);
  }

  function median(arr){ const a=[...arr].sort((x,y)=>x-y); const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2; }
  function updateFps(){ frames++; const now=performance.now(); if(now-lastTick>=1000){ fpsEl.textContent=`${frames} fps`; frames=0; lastTick=now; } }

  // AUTO calibration & enhancement
  const auto = { invert:false, minAreaPx:200, maxAreaPx:20000 };

  function enhanceIllumination(){
    // Top-hat + Black-hat to remove uneven lighting
    const opened = new cv.Mat(); const closed = new cv.Mat();
    cv.morphologyEx(gray, opened, cv.MORPH_OPEN, kernelBig);
    cv.morphologyEx(gray, closed, cv.MORPH_CLOSE, kernelBig);
    const tophat = new cv.Mat(); const blackhat = new cv.Mat();
    cv.subtract(gray, opened, tophat);
    cv.subtract(closed, gray, blackhat);
    const enhanced = new cv.Mat();
    cv.add(gray, tophat, enhanced);
    cv.subtract(enhanced, blackhat, enhanced);
    try { if (clahe) { clahe.apply(enhanced, enhanced); } else { cv.equalizeHist(enhanced, enhanced); } } catch {}
    opened.delete(); closed.delete(); tophat.delete(); blackhat.delete();
    return enhanced;
  }

  function hsvLightMask(){
    const chs = new cv.MatVector(); cv.split(hsv, chs);
    const S = chs.get(1), V = chs.get(2);
    const meanV = cv.mean(V)[0];
    const vMin = Math.min(255, Math.max(120, Math.round(meanV + 20)));
    const sMax = 80; // low saturation (white/light)
    const vMask = new cv.Mat(); const sMask = new cv.Mat();
    cv.threshold(V, vMask, vMin, 255, cv.THRESH_BINARY);
    cv.threshold(S, sMask, sMax, 255, cv.THRESH_BINARY_INV);
    const out = new cv.Mat(); cv.bitwise_and(vMask, sMask, out);
    vMask.delete(); sMask.delete(); S.delete(); V.delete(); chs.delete();
    return out;
  }

  function choosePolarityAndThreshold(enhanced){
    const tests = [cv.THRESH_BINARY+cv.THRESH_OTSU, cv.THRESH_BINARY_INV+cv.THRESH_OTSU];
    let best={score:-1, invert:false, mask:null};
    for(const t of tests){
      const tmp=new cv.Mat();
      cv.threshold(enhanced, tmp, 0, 255, t);
      const opened=new cv.Mat();
      cv.morphologyEx(tmp, opened, cv.MORPH_OPEN, kernelSmall);
      cv.morphologyEx(opened, opened, cv.MORPH_CLOSE, kernelSmall);
      const vec=new cv.MatVector(), hier=new cv.Mat();
      cv.findContours(opened, vec, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      const total = opened.rows*opened.cols; const lo=total*0.0015, hi=total*0.35;
      let good=0; for(let i=0;i<vec.size();i++){ const a=cv.contourArea(vec.get(i)); if(a>lo && a<hi){ good++; } }
      if(good>best.score){ if(best.mask) best.mask.delete(); best={score:good, invert:(t&cv.THRESH_BINARY_INV)!==0, mask:opened}; }
      else { opened.delete(); }
      tmp.delete(); vec.delete(); hier.delete();
    }
    auto.invert = best.invert;
    if (mask) try{mask.delete()}catch{}; mask = best.mask; // keep best

    // Dynamic area from quantiles
    const vec2=new cv.MatVector(), hier2=new cv.Mat();
    cv.findContours(mask, vec2, hier2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    let areas=[]; for(let i=0;i<vec2.size();i++){ areas.push(cv.contourArea(vec2.get(i))); }
    areas.sort((a,b)=>a-b);
    if(areas.length){ const q=p=>areas[Math.max(0,Math.min(areas.length-1,Math.floor(p*(areas.length-1))))]; auto.minAreaPx=Math.max(40,q(0.10)); auto.maxAreaPx=Math.max(auto.minAreaPx+80,q(0.90)); }
    vec2.delete(); hier2.delete();
  }

  function scaleOverlayToVideo(){
    const w=video.videoWidth||640, h=video.videoHeight||480;
    const dpr = window.devicePixelRatio || 1;
    const rect = video.getBoundingClientRect();
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
    overlay.width = Math.round(w * dpr);
    overlay.height = Math.round(h * dpr);
    const sx = overlay.width / w;
    const sy = overlay.height / h;
    octx.setTransform(sx, 0, 0, sy, 0, 0);
    work.width = w; work.height = h; initMats(w,h);
  }

  function houghCircleProposals(){
    // Run Hough on the illumination-corrected blur to boost round pill recall
    const circles = new cv.Mat();
    const tmp = new cv.Mat();
    cv.GaussianBlur(blur, tmp, new cv.Size(3,3), 1.0, 1.0);
    const minR = Math.max(3, Math.round(Math.sqrt(Math.max(1, auto.minAreaPx)/Math.PI)) - 2);
    const maxR = Math.max(minR+2, Math.round(Math.sqrt(Math.max(1, auto.maxAreaPx)/Math.PI)) + 2);
    try{
      cv.HoughCircles(tmp, circles, cv.HOUGH_GRADIENT, 1.2, Math.max(10, minR*2), 120, 22, minR, maxR);
    }catch{}
    const out=[];
    for(let i=0;i<circles.cols;i++){
      const x=circles.data32F[i*3], y=circles.data32F[i*3+1], r=circles.data32F[i*3+2];
      if(!isFinite(x)||!isFinite(y)||!isFinite(r)) continue;
      out.push({cx:x, cy:y, r:Math.max(4, r), score:0.9});
    }
    tmp.delete(); circles.delete();
    return out;
  }

  function processFrame(){
    if(!running) return;
    try {
      const w=video.videoWidth||640, h=video.videoHeight||480;
      if(!w||!h){ requestAnimationFrame(processFrame); return; }
      if (work.width !== w || work.height !== h) { scaleOverlayToVideo(); }

      // Read frame
      wctx.drawImage(video,0,0,w,h);
      if (src) { try { src.delete(); } catch {} }
      src = cv.imread(work);
      cv.cvtColor(src, rgba, cv.COLOR_RGBA2RGB);
      cv.cvtColor(rgba, hsv, cv.COLOR_RGB2HSV);
      cv.cvtColor(rgba, gray, cv.COLOR_RGB2GRAY);

      // Illumination correction + contrast
      const enhanced = enhanceIllumination();
      // Denoise
      cv.GaussianBlur(enhanced, blur, new cv.Size(5,5), 1.1, 1.1);

      // Build three masks: Otsu (auto polarity), Adaptive, and HSV light
      if (frameIndex < warmup || frameIndex % 30 === 0){
        choosePolarityAndThreshold(blur);
      } else {
        const t=(auto.invert?cv.THRESH_BINARY_INV:cv.THRESH_BINARY)+cv.THRESH_OTSU;
        cv.threshold(blur, mask, 0, 255, t);
        cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernelSmall);
        cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kernelSmall);
      }
      const adaptive = new cv.Mat();
      const block = odd(Math.round(Math.min(w,h)*0.07));
      cv.adaptiveThreshold(blur, adaptive, 255, cv.ADAPTIVE_THRESH_MEAN_C, auto.invert?cv.THRESH_BINARY_INV:cv.THRESH_BINARY, Math.max(3,block), 5);
      const hsvMask = hsvLightMask();

      // Fuse masks: (Otsu âˆ§ Adaptive) âˆ¨ HSV
      const fuse1 = new cv.Mat(); cv.bitwise_and(mask, adaptive, fuse1);
      const fused = new cv.Mat(); cv.bitwise_or(fuse1, hsvMask, fused);
      // Clean
      cv.morphologyEx(fused, fused, cv.MORPH_OPEN, kernelSmall);
      cv.morphologyEx(fused, fused, cv.MORPH_CLOSE, kernelSmall);

      // Split touching via distance transform watershed-lite
      cv.distanceTransform(fused, dt, cv.DIST_L2, 3);
      const dtNorm = new cv.Mat(); cv.normalize(dt, dtNorm, 0, 1.0, cv.NORM_MINMAX);
      const fg = new cv.Mat(); cv.threshold(dtNorm, fg, 0.35, 1.0, cv.THRESH_BINARY); fg.convertTo(fg, cv.CV_8U, 255);
      const finalMask = new cv.Mat(); cv.bitwise_and(fused, fg, finalMask);

      // Edges for quality scoring
      cv.Canny(blur, edges, 50, 130);

      // Contour candidates (geometry + edge density)
      cv.findContours(finalMask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let candidates=[];
      for(let i=0;i<contours.size();i++){
        const cnt=contours.get(i); const area=cv.contourArea(cnt);
        if(area<auto.minAreaPx || area>auto.maxAreaPx){ cnt.delete(); continue; }
        const peri=cv.arcLength(cnt,true);
        const circ=(4*Math.PI*area)/(peri*peri+1e-6);
        const hull=new cv.Mat(); cv.convexHull(cnt,hull);
        const solid=area/Math.max(cv.contourArea(hull),1e-6);
        let aspectScore=1.0;
        try{
          if (cnt.total && cnt.total()>=5){
            const rr = cv.fitEllipse(cnt);
            const a = Math.max(rr.size.width, rr.size.height);
            const b = Math.min(rr.size.width, rr.size.height);
            const ratio = b/(a+1e-6); // roundâ†’1, capsuleâ†’~0.4-0.8
            aspectScore = Math.max(0, Math.min(1, ratio));
          }
        }catch{}
        const rect=cv.boundingRect(cnt);
        const eroi = edges.roi(rect); const nz = cv.countNonZero(eroi); eroi.delete();
        const edensity = nz / Math.max(1, rect.width*rect.height);
        const pass = (circ>=0.38 && solid>=0.75 && edensity>0.015 && edensity<0.4);
        if(pass){
          const M=cv.moments(cnt); const cx=M.m10/(M.m00||1), cy=M.m01/(M.m00||1);
          const r=Math.max(4, Math.sqrt(area/Math.PI)|0);
          const score = 0.5*circ + 0.3*solid + 0.2*aspectScore;
          candidates.push({cx,cy,r,score});
        }
        hull.delete(); cnt.delete();
      }

      // Hough circle proposals (boost recall for round pills)
      const hough = houghCircleProposals();
      // Gate Hough by mask coverage (center must be inside fused mask)
      for(const c of hough){
        const px = Math.max(0, Math.min(fused.cols-1, Math.round(c.cx)));
        const py = Math.max(0, Math.min(fused.rows-1, Math.round(c.cy)));
        if (fused.ucharPtr(py, px)[0] > 0) candidates.push(c);
      }

      // Nonâ€‘max suppression (merge nearâ€‘duplicates)
      candidates.sort((a,b)=>b.score-a.score);
      const dets=[]; const used=new Array(candidates.length).fill(false);
      for(let i=0;i<candidates.length;i++){
        if(used[i]) continue; const a=candidates[i]; dets.push(a); used[i]=true;
        for(let j=i+1;j<candidates.length;j++){
          if(used[j]) continue; const b=candidates[j];
          const d=Math.hypot(a.cx-b.cx, a.cy-b.cy);
          if(d < Math.min(a.r,b.r)*0.65){ used[j]=true; }
        }
      }

      // Assign IDs and require confirmation across frames (â‰¥2)
      assignTracks(dets);

      // Draw overlay
      octx.clearRect(0,0,overlay.width, overlay.height);
      octx.lineWidth = 3;
      let confirmed=0;
      for(const d of dets){
        const isConfirmed = (d.age||1) >= 2;
        if (isConfirmed) confirmed++;
        octx.strokeStyle = isConfirmed ? 'rgba(0,200,0,0.98)' : 'rgba(255,165,0,0.9)';
        octx.beginPath(); octx.arc(d.cx, d.cy, Math.max(6,d.r), 0, Math.PI*2); octx.stroke();
        octx.fillStyle = isConfirmed ? 'rgba(255,0,0,0.98)' : 'rgba(255,165,0,0.95)';
        octx.beginPath(); octx.arc(d.cx, d.cy, 4, 0, Math.PI*2); octx.fill();
      }

      // Stable count via median over confirmed count
      recentCounts.push(confirmed); if(recentCounts.length>9) recentCounts.shift();
      countEl.textContent = median(recentCounts);

      // Cleanup temps
      enhanced.delete(); adaptive.delete(); hsvMask.delete(); fuse1.delete(); fused.delete(); dtNorm.delete(); fg.delete(); finalMask.delete();

      updateFps(); frameIndex++;
    } catch (e) {
      console.error(e); showErr(e?.message || String(e));
    }
    requestAnimationFrame(processFrame);
  }

  function setRunning(on){ running=on; if(on) requestAnimationFrame(processFrame); }

  window.cv=window.cv||{};
  cv['onRuntimeInitialized']=()=>{ startBtn.disabled=false; console.log('OpenCV ready'); };

  startBtn.addEventListener('click', async()=>{
    secureContextCheck();
    startBtn.disabled=true;
    const ok=await startCamera();
    if(ok){ scaleOverlayToVideo(); setRunning(true); } else { startBtn.disabled=false; }
  });

  window.addEventListener('beforeunload', ()=>{ try{stream&&stream.getTracks().forEach(t=>t.stop())}catch{}; [src,rgba,hsv,gray,blur,mask,edges,kernelSmall,kernelBig,contours,hierarchy,dt].forEach(m=>{try{m&&m.delete()}catch{}}); if(clahe){try{clahe.delete()}catch{}} });

  secureContextCheck();
</script>
</body>
</html>
