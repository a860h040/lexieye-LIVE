<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lexieye â€” Live Pill Counter (final tuned)</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root{--primary:#007acc;--accent:#d9eaff;--bg:#fdfefe;--glass:rgba(255,255,255,0.2);--border-glass:rgba(255,255,255,0.4);--text:#333}
    *{box-sizing:border-box}
    body{font-family:Poppins,system-ui,Segoe UI,Arial,sans-serif;background:radial-gradient(circle at 40% 40%,var(--bg),#e0f4ff);color:var(--text);margin:0;padding:20px}
    h1{ text-align:center; font-size:2.2rem; color:var(--primary); margin:0 0 12px }
    .wrap{ max-width:1000px; margin:auto; border-radius:24px; padding:16px; background:var(--glass); border:1px solid var(--border-glass); backdrop-filter:blur(20px) }
    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .btn{ background:var(--primary); color:#fff; border:none; border-radius:16px; padding:10px 14px; cursor:pointer }
    .btn[disabled]{ opacity:.6; cursor:not-allowed }
    .pill{ display:inline-block; padding:2px 6px; border-radius:12px; background:#e8f4ff; border:1px solid #cfe7ff }
    .err{ color:#b00020; font-size:.95rem; min-height:1.2em }

    .feed{ position:relative; width:100%; max-width:960px; margin-top:10px }
    video{ display:block; width:100%; height:auto; border-radius:18px; border:2px solid var(--primary) }
    #overlay{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; border-radius:18px }
  </style>
</head>
<body>
  <h1>ðŸ’Š Lexieye â€” Live Pill Counter</h1>
  <div class="wrap">
    <div class="controls">
      <button id="startBtn" class="btn">Enable Camera & Start</button>
      <span class="pill">Detected: <b id="count">0</b></span>
      <span class="pill" id="fps">0 fps</span>
    </div>
    <div class="err" id="err"></div>
    <div class="feed">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>
  </div>

<script>
// ==== LIVE PILL COUNTER â€” Round + Capsules ====
// Update: (1) **Hard lock** confirmed pills for 20s â€” locked tracks are ignored by matcher,
//         still drawn even if missed in a frame, and never jitter during lock.
//         (2) Better **cluster split** when tablets touch: distanceâ€‘transform peaks + softer seeds.
//         (3) Closerâ€‘spacing Hough (smaller minDist) to pick neighbors.

const startBtn=document.getElementById('startBtn');
const errEl=document.getElementById('err');
const video=document.getElementById('video');
const overlay=document.getElementById('overlay');
const octx=overlay.getContext('2d');
const countEl=document.getElementById('count');
const fpsEl=document.getElementById('fps');

let stream=null, running=false, lastTick=performance.now(), frames=0;
let recentCounts=[];

// Process size for speed
const PROC_MAX_W = 360; // smaller -> faster
let procW=0, procH=0, vidW=0, vidH=0, sX=1, sY=1;

// Size prior (autoâ€‘learned)
const sizePrior = { R:null }; // estimated typical radius in VIDEO pixels

// === Lock parameters ===
const LOCK_MS = 20000; // 20 seconds

// Offscreen buffer
const work=document.createElement('canvas');
const wctx=work.getContext('2d');

// OpenCV mats (proc size)
let src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt;
let contours,hierarchy,kSmall,kBig,clahe;

function showErr(m){ errEl.textContent=m||''; console.error(m); }
function odd(n){ return (n%2)?n:n+1; }

async function startCamera(){
  errEl.textContent='';
  const tries=[
    {video:{facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720}}, audio:false},
    {video:{facingMode:{ideal:'environment'}, width:{ideal:960}, height:{ideal:540}}, audio:false},
    {video:true,audio:false}
  ];
  try{
    const devs=await navigator.mediaDevices.enumerateDevices();
    const back=devs.find(d=>d.kind==='videoinput' && /back|environment/i.test(d.label||''));
    if(back) tries.unshift({video:{deviceId:{exact:back.deviceId}, width:{ideal:1280}, height:{ideal:720}}, audio:false});
  }catch{}
  for(const c of tries){
    try{
      stream=await navigator.mediaDevices.getUserMedia(c);
      video.srcObject=stream; video.setAttribute('playsinline','true'); await video.play();
      return true;
    }catch(e){ console.warn('gUM fail',c,e); }
  }
  showErr('Could not start the camera. Use HTTPS or localhost.');
  return false;
}

function syncOverlayAndBuffers(){
  vidW = video.videoWidth||640; vidH = video.videoHeight||480;
  overlay.width = vidW; overlay.height = vidH;
  overlay.style.width = vidW + 'px'; overlay.style.height = vidH + 'px';
  video.style.width = vidW + 'px';

  procW = Math.min(vidW, PROC_MAX_W);
  procH = Math.round(vidH * (procW/vidW));
  work.width = procW; work.height = procH;
  sX = vidW / procW; sY = vidH / procH;

  // (Re)alloc mats at proc size
  [src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt,contours,hierarchy,kSmall,kBig,clahe].forEach(m=>{try{m&&m.delete()}catch{}});
  src=new cv.Mat(procH,procW,cv.CV_8UC4);
  rgb=new cv.Mat(procH,procW,cv.CV_8UC3);
  hsv=new cv.Mat(procH,procW,cv.CV_8UC3);
  gray=new cv.Mat(procH,procW,cv.CV_8UC1);
  blur=new cv.Mat(procH,procW,cv.CV_8UC1);
  mask=new cv.Mat(procH,procW,cv.CV_8UC1);
  adaptive=new cv.Mat(procH,procW,cv.CV_8UC1);
  hsvMask=new cv.Mat(procH,procW,cv.CV_8UC1);
  fused=new cv.Mat(procH,procW,cv.CV_8UC1);
  dt=new cv.Mat(procH,procW,cv.CV_32F);
  contours=new cv.MatVector();
  hierarchy=new cv.Mat();
  const ks=odd(Math.max(3, Math.round(Math.min(procW,procH)*0.02))); // tiny clean
  const kb=odd(Math.max(9, Math.round(Math.min(procW,procH)*0.07)));  // shade removal
  kSmall=cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(ks,ks));
  kBig  =cv.getStructuringElement(cv.MORPH_ELLIPSE,new cv.Size(kb,kb));
  try{ clahe=cv.createCLAHE(2.0, new cv.Size(8,8)); }catch{}
}

function updateFps(){ frames++; const now=performance.now(); if(now-lastTick>=1000){ fpsEl.textContent=`${frames} fps`; frames=0; lastTick=now; } }
function median(a){ const b=[...a].sort((x,y)=>x-y), m=Math.floor(b.length/2); return b.length%2?b[m]:(b[m-1]+b[m])/2; }

function hsvBrightMask(){
  const chs=new cv.MatVector(); cv.split(hsv,chs); const S=chs.get(1), V=chs.get(2);
  const meanV=cv.mean(V)[0];
  const vMin=Math.max(86, Math.round(meanV+4)); // softer for dim areas
  const sMax=130; // allow slight tint
  const vMask=new cv.Mat(), sMask=new cv.Mat();
  cv.threshold(V,vMask,vMin,255,cv.THRESH_BINARY);
  cv.threshold(S,sMask,sMax,255,cv.THRESH_BINARY_INV);
  cv.bitwise_and(vMask,sMask,hsvMask);
  cv.morphologyEx(hsvMask,hsvMask,cv.MORPH_OPEN,kSmall);
  vMask.delete(); sMask.delete(); S.delete(); V.delete(); chs.delete();
}

// === Tracker with 20s hard lock ===
const tracker={tracks:[], nextId:1};
function assignTracks(dets){
  const now=performance.now();
  const maxDist=Math.min(vidW,vidH)*0.06; // in video px

  // reset matched flags
  for(const t of tracker.tracks){ t.matched=false; }

  // greedy assignment â€” **ignore locked tracks** so they can't absorb new neighbors
  for(const d of dets){
    let best=null,bd=1e9;
    for(const t of tracker.tracks){
      const locked = t.lockedUntil && now < t.lockedUntil;
      if(locked) continue; // skip locked tracks completely
      const dd=Math.hypot(d.x - t.x, d.y - t.y);
      if(dd<bd && dd<maxDist){ best=t; bd=dd; }
    }
    if(best){
      best.x=0.7*best.x+0.3*d.x; best.y=0.7*best.y+0.3*d.y;
      best.r1=0.7*(best.r1||d.r1)+0.3*d.r1; best.r2=0.7*(best.r2||d.r2)+0.3*d.r2; best.a=d.a;
      best.seen=now; best.matched=true; best.age=(best.age||0)+1;
      d.x=best.x; d.y=best.y; d.r1=best.r1; d.r2=best.r2; d.a=best.a; d.id=best.id; d.age=best.age; d.locked=false;
    }else{
      const nt={ id:tracker.nextId++, x:d.x, y:d.y, r1:d.r1, r2:d.r2, a:d.a, seen:now, matched:true, age:1, firstConfirmedAt:null, lockedUntil:null };
      tracker.tracks.push(nt); d.id=nt.id; d.age=1; d.locked=false;
    }
  }

  // Promote to locked once confirmed; keep locked tracks alive
  for(const t of tracker.tracks){ if(!t.firstConfirmedAt && (t.age||0)>=2){ t.firstConfirmedAt=now; t.lockedUntil=now+LOCK_MS; } }

  // Expire (longer TTL when locked); unmatched locked tracks remain visible in draw()
  tracker.tracks = tracker.tracks.filter(t=>{ const ttl = (t.lockedUntil && now < t.lockedUntil) ? (LOCK_MS + 3000) : 1200; return (now - t.seen) < ttl; });
}

function process(){
  if(!running) return;
  try{
    if(!video.videoWidth){ requestAnimationFrame(process); return; }
    if(overlay.width!==video.videoWidth || overlay.height!==video.videoHeight || work.width===0){ syncOverlayAndBuffers(); }

    // Read frame (downscaled for speed)
    wctx.drawImage(video,0,0,procW,procH);
    if(src){ try{ src.delete(); }catch{} }
    src=cv.imread(work);
    cv.cvtColor(src,rgb,cv.COLOR_RGBA2RGB);
    cv.cvtColor(rgb,hsv,cv.COLOR_RGB2HSV);
    cv.cvtColor(rgb,gray,cv.COLOR_RGB2GRAY);

    // Illumination correction + blur
    const opened=new cv.Mat(), closed=new cv.Mat(), tophat=new cv.Mat(), blackhat=new cv.Mat(), enh=new cv.Mat();
    cv.morphologyEx(gray,opened,cv.MORPH_OPEN,kBig); cv.morphologyEx(gray,closed,cv.MORPH_CLOSE,kBig);
    cv.subtract(gray,opened,tophat); cv.subtract(closed,gray,blackhat); cv.add(gray,tophat,enh); cv.subtract(enh,blackhat,enh);
    try{ if(clahe) clahe.apply(enh,enh); else cv.equalizeHist(enh,enh);}catch{}
    cv.GaussianBlur(enh,blur,new cv.Size(5,5),1.05,1.05);
    opened.delete(); closed.delete(); tophat.delete(); blackhat.delete(); enh.delete();

    // Masks & fusion: (Otsu âˆ§ Adaptive) âˆ¨ HSV
    cv.threshold(blur,mask,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
    const block = odd(Math.max(9, Math.round(Math.min(procW,procH)*0.09)));
    cv.adaptiveThreshold(blur,adaptive,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,block,5);
    hsvBrightMask();
    const both = new cv.Mat(); cv.bitwise_and(mask,adaptive,both);
    cv.bitwise_or(both,hsvMask,fused); both.delete();
    cv.morphologyEx(fused,fused,cv.MORPH_OPEN,kSmall); cv.morphologyEx(fused,fused,cv.MORPH_CLOSE,kSmall);

    // ===== Better split of touching pills =====
    cv.distanceTransform(fused,dt,cv.DIST_L2,3);
    const dtn = new cv.Mat(); cv.normalize(dt,dtn,0,1,cv.NORM_MINMAX);
    // local maxima as seeds
    const kMax = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
    const maxMap = new cv.Mat(); cv.dilate(dtn,maxMap,kMax);
    const localMax = new cv.Mat(); cv.compare(dtn, maxMap, localMax, cv.CMP_EQ); // 1 where equal
    localMax.convertTo(localMax, cv.CV_8U, 255);
    cv.bitwise_and(localMax, fused, localMax); // only inside pills
    // combine peaks with soft DT threshold
    const fg  = new cv.Mat(); cv.threshold(dtn,fg,0.24,1,cv.THRESH_BINARY); fg.convertTo(fg,cv.CV_8U,255);
    cv.bitwise_or(fg, localMax, fg);
    cv.morphologyEx(fg, fg, cv.MORPH_ERODE, kSmall); // tighten seeds a bit
    const finalMask = new cv.Mat(); cv.bitwise_and(fused,fg,finalMask);
    dtn.delete(); fg.delete(); localMax.delete(); maxMap.delete();

    // Contours (proc space)
    contours.delete(); contours=new cv.MatVector(); hierarchy.delete(); hierarchy=new cv.Mat();
    cv.findContours(finalMask,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

    const gMean = cv.mean(gray)[0];
    const dets=[]; const eqRads=[]; // for prior
    for(let i=0;i<contours.size();i++){
      const cnt=contours.get(i);
      const area=cv.contourArea(cnt); if(area<55){ cnt.delete(); continue; }
      const peri=cv.arcLength(cnt,true);
      const circ=(4*Math.PI*area)/(peri*peri+1e-6);
      const hull=new cv.Mat(); cv.convexHull(cnt,hull); const solid=area/Math.max(cv.contourArea(hull),1e-6);
      const rect=cv.boundingRect(cnt); const roi=finalMask.roi(rect); const cov=cv.countNonZero(roi)/(rect.width*rect.height); roi.delete();

      const r2=gray.roi(rect); const m=new cv.Mat(); const s=new cv.Mat(); cv.meanStdDev(r2,m,s); const meanG=m.doubleAt(0,0); const stdG=s.doubleAt(0,0); r2.delete(); m.delete(); s.delete();

      let isEllipse=false, ex=0,ey=0,er1=0,er2=0,eang=0; try{ if(cnt.total && cnt.total()>=5){ const rr=cv.fitEllipse(cnt); isEllipse=true; ex=rr.center.x; ey=rr.center.y; er1=rr.size.width/2; er2=rr.size.height/2; eang=rr.angle*Math.PI/180; } }catch{}
      const aspect = isEllipse ? Math.min(er1,er2)/Math.max(er1,er2) : 1;

      const roundOK   = (circ>=0.66 && solid>=0.86 && aspect>=0.78);
      const capsuleOK = (solid>=0.88 && aspect>=0.35 && aspect<0.78);
      const brightOK  = (meanG > gMean + 3 && stdG < 50);
      const coverOK   = cov > 0.22;

      if(brightOK && coverOK && (roundOK || capsuleOK)){
        if(roundOK){ const M=cv.moments(cnt); const cx=M.m10/(M.m00||1), cy=M.m01/(M.m00||1); const r=Math.max(6, Math.sqrt(area/Math.PI)); const Rv=r*Math.sqrt((sX+sY)/2); dets.push({type:'circle', x:cx*sX, y:cy*sY, r1:Rv, r2:Rv, a:0, score:circ*solid}); eqRads.push(Rv); }
        else { const Rv=Math.max(er1*sX, er2*sY); dets.push({type:'ellipse', x:ex*sX, y:ey*sY, r1:er1*sX, r2:er2*sY, a:eang, score:solid}); eqRads.push(Rv); }
      }
      hull.delete(); cnt.delete();
    }

    // Hough circles & fuse â€” **closer minDist** to allow neighbors
    const tmp=new cv.Mat(); const circles=new cv.Mat(); cv.GaussianBlur(blur,tmp,new cv.Size(3,3),1.0,1.0);
    try{ cv.HoughCircles(tmp,circles,cv.HOUGH_GRADIENT,1.25, Math.max(6, Math.min(procW,procH)*0.05), 170, 36, 5, Math.round(Math.min(procW,procH)*0.25)); }catch{}
    for(let i=0;i<circles.cols;i++){ const cx=circles.data32F[i*3], cy=circles.data32F[i*3+1], r=circles.data32F[i*3+2]; if(!isFinite(cx)||!isFinite(cy)||!isFinite(r)) continue; const px=Math.min(procW-1,Math.max(0,Math.round(cx))), py=Math.min(procH-1,Math.max(0,Math.round(cy))); if(fused.ucharPtr(py,px)[0]===0) continue; const Rv=r*Math.sqrt((sX+sY)/2); dets.push({type:'circle',x:cx*sX,y:cy*sY,r1:Rv,r2:Rv,a:0,score:0.95}); eqRads.push(Rv); }
    tmp.delete(); circles.delete();

    // === Size prior & hard bounds ===
    if(eqRads.length>=3){ const mid = median(eqRads.filter(v=>isFinite(v))); sizePrior.R = sizePrior.R? (0.7*sizePrior.R+0.3*mid) : mid; }
    const R = sizePrior.R || median(eqRads.length?eqRads:[12]);
    const minR = Math.max(6, R*0.45);
    const maxR = Math.min(Math.min(vidW,vidH)*0.12, R*2.4);

    // Nonâ€‘max suppression (video space)
    dets.sort((a,b)=>b.r1-a.r1); const merged=[]; const used=new Array(dets.length).fill(false);
    for(let i=0;i<dets.length;i++){
      if(used[i]) continue; const a=dets[i];
      const big = Math.max(a.r1,a.r2); const small=Math.min(a.r1,a.r2);
      if(big>maxR || small<minR*0.6){ used[i]=true; continue; }
      merged.push(a); used[i]=true;
      for(let j=i+1;j<dets.length;j++){
        if(used[j]) continue; const b=dets[j];
        const d=Math.hypot(a.x-b.x,a.y-b.y);
        const thr=Math.min(Math.max(a.r1,a.r2), Math.max(b.r1,b.r2))*0.60;
        if(d < thr) used[j]=true;
      }
    }

    assignTracks(merged);

    // Draw (green=confirmed â‰¥2 frames or locked). Also draw locked tracks even if not detected this frame.
    octx.clearRect(0,0,overlay.width,overlay.height); octx.lineWidth=3;
    let confirmed=0; let total = merged.length; const drawnIds=new Set(); const now=performance.now();

    for(const d of merged){
      const t = tracker.tracks.find(t=>t.id===d.id);
      const locked = t && t.lockedUntil && now < t.lockedUntil;
      const ok = (d.age||1)>=2 || locked; // locked stays green
      if(ok) confirmed++;
      drawnIds.add(d.id);
      octx.strokeStyle = ok ? 'rgba(0,200,0,0.98)' : 'rgba(255,165,0,0.9)';
      octx.fillStyle   = ok ? 'rgba(255,0,0,0.98)' : 'rgba(255,165,0,0.95)';
      if(d.type==='ellipse'){
        octx.beginPath(); octx.ellipse(d.x,d.y,Math.max(6,d.r1),Math.max(6,d.r2),d.a,0,Math.PI*2); octx.stroke();
      } else {
        octx.beginPath(); octx.arc(d.x,d.y,Math.max(6,d.r1),0,Math.PI*2); octx.stroke();
      }
      octx.beginPath(); octx.arc(d.x,d.y,4,0,Math.PI*2); octx.fill();
    }

    // Draw lockedâ€‘butâ€‘unmatched tracks (stay green and frozen)
    for(const t of tracker.tracks){
      const locked = t.lockedUntil && now < t.lockedUntil;
      if(locked && !drawnIds.has(t.id)){
        confirmed++; total++; drawnIds.add(t.id);
        octx.strokeStyle='rgba(0,200,0,0.98)'; octx.fillStyle='rgba(255,0,0,0.98)';
        if((t.r2||t.r1) && Math.abs((t.r1||0)-(t.r2||0))>1){
          octx.beginPath(); octx.ellipse(t.x,t.y,Math.max(6,t.r1||8),Math.max(6,t.r2||8),t.a||0,0,Math.PI*2); octx.stroke();
        }else{
          octx.beginPath(); octx.arc(t.x,t.y,Math.max(6,t.r1||8),0,Math.PI*2); octx.stroke();
        }
        octx.beginPath(); octx.arc(t.x,t.y,4,0,Math.PI*2); octx.fill();
      }
    }

    // Show Confirmed / Total
    recentCounts.push(total); if(recentCounts.length>7) recentCounts.shift();
    countEl.textContent = `Confirmed: ${confirmed} / Total: ${median(recentCounts)}`;

    finalMask.delete();
    updateFps();
  }catch(e){ console.error(e); showErr(e?.message||String(e)); }
  requestAnimationFrame(process);
}

window.cv=window.cv||{}; cv.onRuntimeInitialized=()=>{ startBtn.disabled=false; };

startBtn.addEventListener('click', async()=>{
  startBtn.disabled=true; const ok=await startCamera();
  if(ok){ const ready=()=>{ syncOverlayAndBuffers(); running=true; requestAnimationFrame(process); }; if(video.readyState>=1) ready(); else video.addEventListener('loadedmetadata', ready, {once:true}); window.addEventListener('resize', ()=>{ if(video.videoWidth) syncOverlayAndBuffers(); }); } else { startBtn.disabled=false; }
});

window.addEventListener('beforeunload', ()=>{ try{stream&&stream.getTracks().forEach(t=>t.stop());}catch{}; [src,rgb,hsv,gray,blur,mask,adaptive,hsvMask,fused,dt,contours,hierarchy,kSmall,kBig,clahe].forEach(m=>{try{m&&m.delete()}catch{}}); });
</script>
</body>
</html>
